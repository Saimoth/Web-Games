<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Marble Game</title>
  <style>
    html, body {
      margin:0;
      padding:0;
      overflow:hidden;
      background:#000;
      overscroll-behavior: none;
    }
    /* Left: Speed & Boom (single row) */
    #ui-left {
      position:fixed; top:0; left:0;
      height:48px;
      background:rgba(0,0,0,0.6);
      display:flex; gap:8px; align-items:center;
      padding:6px 8px; box-sizing:border-box;
      z-index:1000; user-select:none;
    }
    /* Right: two rows of controls */
    #ui-right {
      position:fixed; top:0; right:0;
      height:96px;
      background:rgba(0,0,0,0.6);
      display:flex; flex-direction:column;
      justify-content:flex-start;
      padding:6px 8px; box-sizing:border-box;
      z-index:1000; user-select:none;
    }
    #ui-right .row {
      display:flex; gap:8px;
      margin-bottom:8px;
    }
    button {
      padding:6px 12px;
      font-size:16px;
      font-family:system-ui,sans-serif;
      background:#222;
      color:#eee;
      border:1px solid #555;
      border-radius:6px;
    }
    button.active {
      background:#4a90e2;
      color:#fff;
      border-color:#4a90e2;
    }
    canvas {
      position:fixed; top:0; left:0;
      z-index:0;
      display:block;
      touch-action:none;
    }
  </style>
</head>
<body>
  <div id="ui-left">
    <button id="btnSpeed">Speed</button>
    <button id="btnBoom">Boom</button>
  </div>
  <div id="ui-right">
    <div class="row">
      <button id="btnLine" class="active">Line</button>
      <button id="btnBackRight">Back</button>
    </div>
    <div class="row">
      <button id="btnBall">Ball</button>
      <button id="btnBackLeft">Back</button>
    </div>
  </div>

  <script src="./P5.js"></script>
  <script>
    if (typeof window.p5 === "undefined") {
      document.body.innerHTML =
        '<div style="color:#fff;font-family:system-ui;text-align:center;margin-top:30vh;">Couldnâ€™t find p5.js.<br>Check the script src path and filename.</div>';
    }

    /* ===== Config ===== */
    const PHYSICS_ITERS         = 2;
    const MIN_SEGMENT_DIST      = 5;
    const UI_HEIGHT             = 48;
    const GRAVITY               = 0.3;
    const RESTITUTION_BALL_BALL = 0.85;
    const RESTITUTION_BALL_LINE = 0.35;
    const AIR_DAMPING           = 0.999;
    const NORMAL_STOP_THRESHOLD = 0.2;
    const MAX_SUBSTEP_MOVE      = 6;

    const SLEEP_SPEED    = 0.05;
    const SLEEP_SPEED_SQ = SLEEP_SPEED * SLEEP_SPEED;
    const SLEEP_FRAMES   = 25;
    const WAKE_IMPULSE   = 0.6;
    const POS_SLOP       = 0.3;
    const PEN_CORRECT    = 0.8;

    let SMOOTH_HISTORY = 10;
    const BALL_RADIUS  = 12;

    const BALL_HUES = [0, 30, 60, 120, 240, 300];
    let ballColorIndex = 0;

    const explosionRadius  = 100;
    const explosionForce   = 50;
    const numParticles     = 30;
    const particleSpeedMin = 2;
    const particleSpeedMax = 6;
    const particleLifespan = 30;

    let speedMode = false;
    const SPEED_MAG = 10;

    /* ===== Globals ===== */
    let mode          = 'line',
        lines         = [],
        lineSegments  = [],
        currentLine   = null,
        balls         = [],
        particles     = [],
        cnv;

    /* ===== Geometry / Quadtree ===== */
    class Rect {
      constructor(x,y,hw,hh){ this.x=x; this.y=y; this.hw=hw; this.hh=hh; }
      contains(p){
        return p.x >= this.x-this.hw && p.x <= this.x+this.hw &&
               p.y >= this.y-this.hh && p.y <= this.y+this.hh;
      }
      intersects(r){
        return !(r.x - r.hw > this.x + this.hw ||
                 r.x + r.hw < this.x - this.hw ||
                 r.y - r.hh > this.y + this.hh ||
                 r.y + r.hh < this.y - this.hh);
      }
    }
    class Quadtree {
      constructor(boundary, cap=4, depth=0, maxD=8){
        this.boundary=boundary; this.capacity=cap;
        this.points=[]; this.divided=false;
        this.depth=depth; this.maxDepth=maxD;
      }
      subdivide(){
        const {x,y,hw,hh} = this.boundary;
        this.nw = new Quadtree(new Rect(x-hw/2,y-hh/2,hw/2,hh/2), this.capacity, this.depth+1, this.maxDepth);
        this.ne = new Quadtree(new Rect(x+hw/2,y-hh/2,hw/2,hh/2), this.capacity, this.depth+1, this.maxDepth);
        this.sw = new Quadtree(new Rect(x-hw/2,y+hh/2,hw/2,hh/2), this.capacity, this.depth+1, this.maxDepth);
        this.se = new Quadtree(new Rect(x+hw/2,y+hh/2,hw/2,hh/2), this.capacity, this.depth+1, this.maxDepth);
        this.divided = true;
      }
      insert(pt){
        if(!this.boundary.contains(pt)) return false;
        if(this.points.length < this.capacity || this.depth >= this.maxDepth){
          this.points.push(pt);
          return true;
        }
        if(!this.divided) this.subdivide();
        return this.nw.insert(pt) || this.ne.insert(pt) || this.sw.insert(pt) || this.se.insert(pt);
      }
      query(range, found=[]){
        if(!this.boundary.intersects(range)) return found;
        for(const p of this.points) if(range.contains(p)) found.push(p);
        if(this.divided){
          this.nw.query(range,found);
          this.ne.query(range,found);
          this.sw.query(range,found);
          this.se.query(range,found);
        }
        return found;
      }
    }
    function closestPointOnSegment(ax,ay,bx,by,px,py){
      const abx=bx-ax, aby=by-ay;
      const apx=px-ax, apy=py-ay;
      const ab2=Math.max(abx*abx+aby*aby,1e-8);
      let t=(apx*abx+apy*aby)/ab2;
      t=Math.max(0,Math.min(1,t));
      return { x: ax+abx*t, y: ay+aby*t, t };
    }

    /* ===== Line ===== */
    class Node {
      constructor(x,y){ this.x=x; this.y=y; this.next=null; this.prev=null; }
    }
    class LineLL {
      constructor(x,y,col=255,w=3){
        const n=new Node(x,y);
        this.head=n; this.tail=n; this.length=1;
        this.strokeCol=col; this.strokeW=w;
      }
      addPoint(x,y){
        const n=new Node(x,y);
        this.tail.next=n; n.prev=this.tail;
        this.tail=n; this.length++;
        this.smoothLast(SMOOTH_HISTORY);
      }
      smoothLast(k){
        let arr=[], node=this.tail;
        for(let i=0;i<k&&node;i++){ arr.push(node); node=node.prev; }
        if(arr.length<3) return;
        for(let i=1;i<arr.length-1;i++){
          const curr=arr[i], prev=arr[i+1], next=arr[i-1];
          curr.x=(prev.x+2*curr.x+next.x)*0.25;
          curr.y=(prev.y+2*curr.y+next.y)*0.25;
        }
      }
      draw(){
        stroke(this.strokeCol); strokeWeight(this.strokeW); noFill();
        let n=this.head;
        while(n&&n.next){ line(n.x,n.y,n.next.x,n.next.y); n=n.next; }
      }
      segments(){
        const out=[]; let n=this.head;
        while(n&&n.next){ out.push({ ax:n.x, ay:n.y, bx:n.next.x, by:n.next.y }); n=n.next; }
        return out;
      }
    }

    /* ===== Particle ===== */
    class Particle {
      constructor(x,y){
        this.pos=createVector(x,y);
        this.vel=p5.Vector.random2D().mult(random(particleSpeedMin, particleSpeedMax));
        this.lifespan=particleLifespan;
      }
      update(){ this.pos.add(this.vel); this.lifespan--; }
      draw(){
        noStroke();
        fill(60,100,100,map(this.lifespan,0,particleLifespan,0,100));
        circle(this.pos.x,this.pos.y,4);
      }
    }

    /* ===== Ball ===== */
    class Ball {
      constructor(x,y){
        this.pos=createVector(x,y);
        this.vel=createVector(random(-1,1), random(-2,-1));
        this.r=BALL_RADIUS;
        const hue=BALL_HUES[ballColorIndex];
        ballColorIndex=(ballColorIndex+1)%BALL_HUES.length;
        this.c=color(hue,80,100);
        this.mass=this.r*this.r;
        this.sleeping=false; this.sleepCount=0;
      }
      integrate(dt){
        if(this.sleeping) return;
        this.vel.y += GRAVITY * dt;
        this.pos.x += this.vel.x * dt;
        this.pos.y += this.vel.y * dt;
      }
      draw(){
        noStroke(); fill(this.c);
        circle(this.pos.x,this.pos.y,this.r*2);
      }
      offscreen(){ return this.pos.y - this.r > height; }
      speedSq(){ return this.vel.x*this.vel.x + this.vel.y*this.vel.y; }
      trySleep(){
        if(this.speedSq() < SLEEP_SPEED_SQ){
          this.sleepCount++;
          if(this.sleepCount >= SLEEP_FRAMES){
            this.sleeping=true; this.vel.set(0,0);
          }
        } else this.sleepCount=0;
      }
      wake(){ this.sleeping=false; this.sleepCount=0; }
    }

    /* ===== p5 Hooks ===== */
    function setup(){
      cnv=createCanvas(windowWidth,windowHeight);
      cnv.style('position','fixed').style('z-index','0');
      colorMode(HSB,360,100,100);
      background(0);
      setupButtons();
    }

    function draw(){
      background(0);
      for(let i=0;i<PHYSICS_ITERS;i++) physicsStep(1/PHYSICS_ITERS);
      lines.forEach(ln=>ln.draw());
      if(currentLine) currentLine.draw();
      balls.forEach(b=>b.draw());
      for(let i=particles.length-1;i>=0;i--){
        particles[i].update(); particles[i].draw();
        if(particles[i].lifespan<=0) particles.splice(i,1);
      }
    }

    function windowResized(){
      resizeCanvas(windowWidth,windowHeight);
    }

    /* ===== Input ===== */
    function touchStarted(){ return handlePointerStart(getPointer()); }
    function touchMoved(){ return handlePointerDrag(getPointer()); }
    function touchEnded(){ endLine(); return false; }
    function mousePressed(){
      if(touches&&touches.length>0) return;
      handlePointerStart({x:mouseX,y:mouseY});
    }
    function mouseDragged(){
      if(mode==='line'&&currentLine&&mouseY>UI_HEIGHT){
        handlePointerDrag({x:mouseX,y:mouseY});
      }
    }
    function mouseReleased(){
      if(mode==='line') endLine();
    }

    function handlePointerStart({x,y}){
      if(y<=UI_HEIGHT) return false;
      if(mode==='ball') balls.push(new Ball(x,y));
      else startLine(x,y);
      return false;
    }
    function handlePointerDrag({x,y}){
      if(!currentLine||y<=UI_HEIGHT) return false;
      const dx=x-currentLine.tail.x, dy=y-currentLine.tail.y;
      if(dx*dx+dy*dy>=MIN_SEGMENT_DIST*MIN_SEGMENT_DIST){
        extendLine(x,y); rebuildSegments();
      }
      return false;
    }
    function getPointer(){
      return touches&&touches.length>0
        ? {x:touches[0].x,y:touches[0].y}
        : {x:mouseX,y:mouseY};
    }

    function startLine(x,y){ currentLine=new LineLL(x,y); }
    function extendLine(x,y){ currentLine.addPoint(x,y); }
    function endLine(){
      if(currentLine&&currentLine.length>1){
        lines.push(currentLine); rebuildSegments();
      }
      currentLine=null;
    }
    function rebuildSegments(){
      lineSegments=[]; lines.forEach(ln=>lineSegments.push(...ln.segments()));
      balls.forEach(b=>b.wake());
    }

    /* ===== Buttons & Boom & Speed ===== */
    function setupButtons(){
      const bBall   =document.getElementById('btnBall'),
            bLine   =document.getElementById('btnLine'),
            bBoom   =document.getElementById('btnBoom'),
            bSpeed  =document.getElementById('btnSpeed'),
            bBackL  =document.getElementById('btnBackLeft'),
            bBackR  =document.getElementById('btnBackRight');

      function setMode(m){
        mode=m;
        bBall.classList.toggle('active',m==='ball');
        bLine.classList.toggle('active',m==='line');
      }
      function bind(el,fn){
        el.addEventListener('click', e=>{
          e.stopPropagation();
          fn();
        });
        el.addEventListener('touchstart', e=>{
          e.stopPropagation();
          e.preventDefault();
          fn();
        },{passive:false});
      }

      bind(bBall,  ()=>setMode('ball'));
      bind(bLine,  ()=>setMode('line'));
      bind(bBackL, ()=>{ if(balls.length>0) balls.pop(); });
      bind(bBackR, ()=>{ if(lines.length>0) lines.pop(); rebuildSegments(); });
      bind(bBoom,  doBoom);
      bind(bSpeed, ()=>{ speedMode=!speedMode; bSpeed.classList.toggle('active',speedMode); });

      setMode('line');
    }

    function doBoom(){
      if(!balls.length) return;
      const i=floor(random(balls.length)), b=balls.splice(i,1)[0],
            ex=b.pos.x, ey=b.pos.y;
      for(const o of balls){
        const d=p5.Vector.sub(o.pos,createVector(ex,ey)), dist=d.mag();
        if(dist<explosionRadius){
          const strength=explosionForce*pow(1-dist/explosionRadius,2);
          o.vel.add(d.normalize().mult(strength));
        }
      }
      for(let j=0;j<numParticles;j++) particles.push(new Particle(ex,ey));
    }

    /* ===== Physics ===== */
    function physicsStep(dtFactor){
      balls=balls.filter(b=>!b.offscreen());
      let maxSpeed=0;
      balls.forEach(b=>{ if(!b.sleeping) maxSpeed=Math.max(maxSpeed,b.vel.mag()); });
      const steps=Math.max(1,Math.ceil((maxSpeed*dtFactor)/MAX_SUBSTEP_MOVE));
      const dt=dtFactor/steps;
      for(let s=0;s<steps;s++) balls.forEach(b=>b.integrate(dt));

      balls.forEach(b=>{
        if(b.pos.x-b.r>width) b.pos.x=-b.r;
        if(b.pos.x+b.r<0)     b.pos.x=width+b.r;
      });

      const qt1=new Quadtree(new Rect(width/2,height/2,width/2,height/2),4);
      balls.forEach((b,i)=>qt1.insert({x:b.pos.x,y:b.pos.y,i}));
      balls.forEach((b1,i)=>{
        const r=new Rect(b1.pos.x,b1.pos.y,b1.r*2,b1.r*2);
        qt1.query(r).forEach(p=>{ if(p.i>i) resolveBallBall(b1,balls[p.i]); });
      });

      const qt2=new Quadtree(new Rect(width/2,height/2,width/2,height/2),4);
      balls.forEach((b,i)=>qt2.insert({x:b.pos.x,y:b.pos.y,i}));
      for(let i=balls.length-1;i>=0;i--){
        const b2=balls[i], r=new Rect(b2.pos.x,b2.pos.y,b2.r*2,b2.r*2);
        qt2.query(r).forEach(p=>{ if(p.i<i) resolveBallBall(balls[p.i],b2); });
      }

      balls.forEach(b=>resolveBallLines(b));
      balls.forEach(b=>b.vel.mult(AIR_DAMPING));

      if(speedMode){
        balls.forEach(b=>{
          if(b.vel.mag()>0) b.vel.setMag(SPEED_MAG);
        });
      }

      balls.forEach(b=>{ if(!b.sleeping) b.trySleep(); });
    }

    function resolveBallBall(b1,b2){
      const n=p5.Vector.sub(b2.pos,b1.pos);
      const dist=n.mag(), minD=b1.r+b2.r;
      if(dist===0||dist>=minD-POS_SLOP) return;
      const normal=n.copy().div(dist||1e-8);
      const overlap=(minD-dist)*PEN_CORRECT;
      const mSum=b1.mass+b2.mass;
      b1.pos.add(p5.Vector.mult(normal,-overlap*(b2.mass/mSum)));
      b2.pos.add(p5.Vector.mult(normal, overlap*(b1.mass/mSum)));
      const rv=p5.Vector.sub(b2.vel,b1.vel);
      const velN=rv.dot(normal);
      if(velN>0) return;
      const j=-(1+RESTITUTION_BALL_BALL)*velN/(1/b1.mass+1/b2.mass);
      const imp=p5.Vector.mult(normal,j);
      b1.vel.sub(p5.Vector.mult(imp,1/b1.mass));
      b2.vel.add(p5.Vector.mult(imp,1/b2.mass));
      if(Math.abs(j)>WAKE_IMPULSE){ b1.wake(); b2.wake(); }
    }

    function resolveBallLines(b){
      if(!lineSegments.length) return;
      for(const seg of lineSegments){
        const cp=closestPointOnSegment(seg.ax,seg.ay,seg.bx,seg.by,b.pos.x,b.pos.y);
        const dx=b.pos.x-cp.x, dy=b.pos.y-cp.y;
        const dist2=dx*dx+dy*dy, r=b.r;
        if(dist2<r*r-POS_SLOP){
          const dist=Math.sqrt(dist2)||1e-8;
          const normal=createVector(dx/dist,dy/dist);
          b.pos.add(p5.Vector.mult(normal,(r-dist)*PEN_CORRECT));
          const vn=b.vel.dot(normal);
          if(vn<0){
            b.vel.sub(p5.Vector.mult(normal,(1+RESTITUTION_BALL_LINE)*vn));
            const vn2=b.vel.dot(normal);
            if(Math.abs(vn2)<NORMAL_STOP_THRESHOLD){
              b.vel.sub(normal.copy().mult(vn2));
            }
          }
          b.wake();
        }
      }
    }
  </script>
</body>
</html>