<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mobile Healing Demo</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      height: 100%; width: 100%;
      font-family: sans-serif;
      background: #111; color: #fff;
      position: relative;
    }
    .targets {
      display: flex; justify-content: space-around;
      align-items: center; height: 100%;
    }
    .target {
      width: 60px; height: 60px;
      border: 3px solid #444;
      position: relative; background: #222;
      display: flex; align-items: flex-end;
      cursor: pointer; overflow: visible;
    }
    .target.selected { border-color: gold; }
    .health-bar { width:100%; height:10px; background:#333; }
    .health-bar-fill { width:100%; height:100%; background:#0f0; }
    .buff-hot {
      position: absolute; left:0; top:4px;
      height:4px; background:#0f0; width:0;
    }
    .double-damage-indicator {
      position: absolute; top:-12px; left:50%;
      transform: translateX(-50%);
      width:16px; height:16px; border-radius:50%;
      background: rgba(255,0,0,0.8); border:2px solid #f00;
      display: none;
    }
    .mitigation-indicator {
      position: absolute; top:-14px; left:50%;
      transform: translateX(-50%);
      width:20px; height:20px; border:2px solid #888;
      border-radius:50%; display: none;
      pointer-events: none;
    }
    .floating-text {
      position: absolute; font-weight: bold;
      pointer-events: none;
    }
    .floating-text.heal {
      top:-20px; left:50%; transform: translateX(-50%);
      color:#0f0; font-size:14px;
      animation: fadeUp 2s forwards;
    }
    .floating-text.dmg {
      bottom:-20px; left:50%; transform: translateX(-50%);
      color:#f00; font-size:14px;
      animation: fadeDown 2s forwards;
    }
    .floating-text.crit { font-size:24px!important; }
    @keyframes fadeUp {
      from { opacity:1; transform: translateX(-50%) translateY(0); }
      to   { opacity:0; transform: translateX(-50%) translateY(-20px); }
    }
    @keyframes fadeDown {
      from { opacity:1; transform: translateX(-50%) translateY(0); }
      to   { opacity:0; transform: translateX(-50%) translateY(20px); }
    }
    .cast-bar {
      position: absolute; bottom:100px; left:10px; right:10px;
      height:8px; background:#333; display:none;
    }
    .cast-bar.active { display:block; }
    .cast-progress { height:100%; width:0; background:#00f; }
    .spells {
      position: absolute; bottom:10px; left:0; right:0;
      display:flex; justify-content:space-around; padding:0 10px;
    }
    .spell {
      width:60px; height:60px; border:2px solid #888;
      border-radius:8px; background:#333; font-size:20px;
      position:relative; display:flex; align-items:center;
      justify-content:center; cursor:pointer; flex-direction:column;
    }
    .spell.disabled { opacity:0.4; pointer-events:none; }
    .spells.locked .spell {
      opacity:0.4!important; pointer-events:none!important;
    }
    .spell-label {
      font-size:10px; text-align:center; line-height:1.1;
    }
    .overlay {
      position:absolute; top:0; left:0; width:100%; height:100%;
      background:rgba(0,0,0,0.7); color:#fff;
      display:flex; align-items:center; justify-content:center;
      font-size:18px;
    }
    .game-over-overlay {
      position:fixed; top:0; left:0; width:100%; height:100%;
      background:rgba(0,0,0,0.85); color:#fff;
      display:flex; align-items:center; justify-content:center;
      font-size:24px; z-index:999; flex-direction:column;
    }
  </style>
</head>
<body>

  <div class="targets">
    <div class="target" data-index="0">
      <div class="mitigation-indicator"></div>
      <div class="double-damage-indicator"></div>
      <div class="buff-hot"></div>
      <div class="health-bar"><div class="health-bar-fill"></div></div>
    </div>
    <div class="target" data-index="1">
      <div class="mitigation-indicator"></div>
      <div class="double-damage-indicator"></div>
      <div class="buff-hot"></div>
      <div class="health-bar"><div class="health-bar-fill"></div></div>
    </div>
    <div class="target" data-index="2">
      <div class="mitigation-indicator"></div>
      <div class="double-damage-indicator"></div>
      <div class="buff-hot"></div>
      <div class="health-bar"><div class="health-bar-fill"></div></div>
    </div>
    <div class="target" data-index="3">
      <div class="mitigation-indicator"></div>
      <div class="double-damage-indicator"></div>
      <div class="buff-hot"></div>
      <div class="health-bar"><div class="health-bar-fill"></div></div>
    </div>
  </div>

  <div class="cast-bar"><div class="cast-progress"></div></div>

  <div class="spells">
    <div class="spell" id="spell1">ðŸ›¡<div class="spell-label">Mitigate<br>(15s)</div></div>
    <div class="spell" id="spell2">ðŸŒ±<div class="spell-label">HoT<br>(8s)</div></div>
    <div class="spell" id="spell3">âœš<div class="spell-label">Single<br>Cast</div></div>
    <div class="spell" id="spell4">ðŸ’ž<div class="spell-label">AoE<br>(15s)</div></div>
  </div>

<script>
(function(){
  const maxHP=100, baseHeal=30, mitDur=5000, hotDur=8000;
  const spellsCfg={ spell1:{cd:15000,last:-1e9},
                    spell2:{cd:8000, last:-1e9},
                    spell3:{cast:2000},
                    spell4:{cd:15000,last:-1e9} };
  let targets=Array(4).fill().map(_=>({
      hp:maxHP, mitEnd:0, hotEnd:0, ddEnd:0
    })),
    selected=0, globalCD=0, startTime=Date.now(), gameOver=false;

  const targetsEl=document.querySelectorAll('.target'),
        spellEl={ spell1:document.getElementById('spell1'),
                  spell2:document.getElementById('spell2'),
                  spell3:document.getElementById('spell3'),
                  spell4:document.getElementById('spell4') },
        spellsContainer=document.querySelector('.spells'),
        castBar=document.querySelector('.cast-bar'),
        castProg=document.querySelector('.cast-progress');

  const now=()=>Date.now(),
        clamp=(v,m,M)=>Math.max(m,Math.min(M,v)),
        rand=(a,b)=>Math.random()*(b-a)+a;

  // init
  targetsEl.forEach((el,i)=>{
    if(i===0) el.classList.add('selected');
    updHP(i);
    el.addEventListener('click',()=>{
      if(gameOver) return;
      targetsEl.forEach(x=>x.classList.remove('selected'));
      el.classList.add('selected');
      selected=+el.dataset.index;
    });
  });

  // damage loops
  function scheduleDamage(i){
    setTimeout(()=>{
      if(gameOver) return;
      let t=now(), dmg=rand(2,5)*rand(0.9,1.1), crit=false;
      if(Math.random()<0.25){ dmg*=2; crit=true; }
      if(t<targets[i].ddEnd) dmg*=2;
      if(t<targets[i].mitEnd) dmg*=0.25;
      dmg=Math.round(dmg);
      targets[i].hp=clamp(targets[i].hp-dmg,0,maxHP);
      updHP(i);
      showFloating(i,dmg,'dmg',crit);
      if(targets[i].hp===0 && !gameOver) endGame();
      else scheduleDamage(i);
    }, rand(950,1050));
  }
  for(let i=0;i<4;i++) scheduleDamage(i);

  // UI refresh
  const uiInt=setInterval(()=>{
    targets.forEach((_,i)=>{ updHot(i); updMit(i); updDD(i); });
  },100);

  // double-damage
  const ddInt=setInterval(()=>{
    if(gameOver) return;
    let idx=Math.floor(Math.random()*4);
    targets[idx].ddEnd=now()+10000;
  },15000);

  function updHP(i){
    let f=targetsEl[i].querySelector('.health-bar-fill');
    f.style.width=(targets[i].hp/maxHP*100)+'%';
    f.style.background=targets[i].hp>0?'#0f0':'#800';
  }
  function updHot(i){
    let bar=targetsEl[i].querySelector('.buff-hot'), t=now();
    bar.style.width=t<targets[i].hotEnd?((targets[i].hotEnd-t)/hotDur*100)+'%':'0';
  }
  function updMit(i){
    let ind=targetsEl[i].querySelector('.mitigation-indicator');
    ind.style.display=now()<targets[i].mitEnd?'block':'none';
  }
  function updDD(i){
    let ind=targetsEl[i].querySelector('.double-damage-indicator');
    ind.style.display=now()<targets[i].ddEnd?'block':'none';
  }

  function showFloating(i,amt,type,crit=false){
    let el=targetsEl[i], ft=document.createElement('div');
    ft.className='floating-text '+(type==='heal'?'heal':'dmg')+(crit?' crit':'');
    ft.textContent=(type==='heal'?'+':'-')+Math.abs(amt);
    el.appendChild(ft);
    setTimeout(()=>el.removeChild(ft),2000);
  }

  function endGame(){
    gameOver=true;
    clearInterval(uiInt); clearInterval(ddInt);
    spellsContainer.classList.add('locked');
    let dur=((now()-startTime)/1000).toFixed(1),
        ov=document.createElement('div');
    ov.className='game-over-overlay';
    ov.innerHTML=`Game Over<br>You lasted ${dur} s`;
    document.body.appendChild(ov);
  }

  function startCD(id,ms){
    let el=spellEl[id], ov=el.querySelector('.overlay');
    if(!ov){ ov=document.createElement('div'); ov.className='overlay'; el.appendChild(ov); }
    el.classList.add('disabled');
    let s=Math.ceil(ms/1000);
    ov.textContent=s;
    let iv=setInterval(()=>{
      if(--s<=0){ clearInterval(iv); el.classList.remove('disabled'); ov.remove(); }
      else ov.textContent=s;
    },1000);
  }

  function tryInstant(id,eff){
    if(gameOver) return;
    let t=now(), sp=spellsCfg[id];
    if(t<globalCD||t-sp.last<sp.cd||(id!=='spell4'&&selected===null)) return;
    sp.last=t; globalCD=t+1000;
    startCD(id,sp.cd);
    spellsContainer.classList.add('locked');
    setTimeout(()=>spellsContainer.classList.remove('locked'),1000);
    eff();
  }

  function doCast(id,dur,eff){
    if(gameOver||selected===null) return;
    let idx=selected;
    spellsContainer.classList.add('locked');
    spellEl[id].classList.add('disabled');
    castBar.classList.add('active');
    let st=now(), iv=setInterval(()=>{
      castProg.style.width=clamp((now()-st)/dur,0,1)*100+'%';
    },50);
    setTimeout(()=>{
      clearInterval(iv);
      castBar.classList.remove('active');
      castProg.style.width='0';
      spellEl[id].classList.remove('disabled');
      spellsContainer.classList.remove('locked');
      eff(idx);
    },dur);
  }

  // Spell 1: Mitigation
  spellEl.spell1.addEventListener('click',()=>{
    tryInstant('spell1',()=>{
      targets[selected].mitEnd=now()+mitDur; updMit(selected);
    });
  });
  // Spell 2: HoT now heals baseHeal/2
  spellEl.spell2.addEventListener('click',()=>{
    tryInstant('spell2',()=>{
      let idx=selected, halfHeal=Math.round(baseHeal/2);
      targets[idx].hotEnd=now()+hotDur; updHot(idx);
      let ticks=hotDur/2000, iv=setInterval(()=>{
        if(--ticks<0){clearInterval(iv);return;}
        if(targets[idx].hp>0){
          targets[idx].hp=clamp(targets[idx].hp+halfHeal,0,maxHP);
          updHP(idx); showFloating(idx,halfHeal,'heal');
        }
      },2000);
    });
  });
  // Spell 3: Single heal
  spellEl.spell3.addEventListener('click',()=>{
    doCast('spell3',spellsCfg.spell3.cast,idx=>{
      let heal=baseHeal*rand(0.9,1.1), crit=false;
      if(Math.random()<0.25){heal*=2;crit=true;}
      heal=Math.round(heal);
      if(targets[idx].hp>0){
        targets[idx].hp=clamp(targets[idx].hp+heal,0,maxHP);
        updHP(idx); showFloating(idx,heal,'heal',crit);
      }
    });
  });
  // Spell 4: AoE
  spellEl.spell4.addEventListener('click',()=>{
    tryInstant('spell4',()=>{
      targets.forEach((tar,i)=>{
        if(tar.hp<=0) return;
        let heal=(baseHeal/2)*rand(0.9,1.1), crit=false;
        if(Math.random()<0.25){heal*=2;crit=true;}
        heal=Math.round(heal);
        tar.hp=clamp(tar.hp+heal,0,maxHP);
        updHP(i); showFloating(i,heal,'heal',crit);
      });
    });
  });

})();
</script>

</body>
</html>