<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Xstitch</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 1.5rem;
      background: #fafafa;
      color: #333;
    }
    h1 {
      margin-bottom: 0.5rem;
    }
    #controls {
      margin-bottom: 1rem;
    }
    label {
      margin: 0 0.5rem;
      font-size: 1rem;
    }
    select, button, input[type=range] {
      padding: 0.4rem 0.8rem;
      font-size: 1rem;
      margin-left: 0.3rem;
      vertical-align: middle;
    }
    #info {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #555;
    }
    #output {
      margin: 1rem auto;
      padding: 1rem;
      max-width: 90vw;
      background: #fff;
      border: 1px solid #ddd;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    #output canvas {
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      display: block;
      margin: 0 auto;
    }
  </style>
</head>
<body>

  <h1>Xstitch</h1>

  <div id="controls">
    <label>
      Scale:
      <select id="sizeSelect">
        <option value="32">32</option>
        <option value="64">64</option>
        <option value="128" selected>128</option>
      </select>
    </label>
    <label>
      Palette:
      <select id="paletteSelect">
        <option>Standard</option>
      </select>
    </label>
    <label>
      Slash threshold:
      <input type="range" id="diag1Thresh" min="0" max="100" value="75">
      <span id="diag1Val">75</span>%
    </label>
    <label>
      Cross threshold:
      <input type="range" id="diag2Thresh" min="0" max="100" value="25">
      <span id="diag2Val">40</span>%
    </label>
    <button id="uploadBtn">Upload Photo</button>
    <input type="file" id="fileInput" accept="image/*" style="display:none">
  </div>

  <div id="info"></div>
  <div id="output"></div>

  <script>
    // only the Standard 32-colour palette
    const palettes = {
      Standard: [
        "#000000","#FFFFFF","#555555","#AAAAAA","#333333","#CCCCCC",
        "#FF0000","#00FF00","#0000FF","#FFFF00","#FF00FF","#00FFFF",
        "#800000","#008000","#000080","#808000","#800080","#008080",
        "#FFA500","#A52A2A","#228B22","#DAA520","#2E8B57","#6B8E23",
        "#800020","#406080","#608040","#804060","#408060","#604080"
      ]
    };

    // helper: hex → [r,g,b]
    function hexToRgb(hex) {
      hex = hex.replace(/^#/, '');
      if (hex.length === 3) hex = hex.split('').map(c=>c+c).join('');
      const val = parseInt(hex,16);
      return [(val>>16)&255, (val>>8)&255, val&255];
    }
    // find two nearest palette colours
    function findTwoNearest(palette, r, g, b) {
      let i1=0, i2=1, d1=Infinity, d2=Infinity;
      palette.forEach((c,i)=>{
        const dr=r-c[0], dg=g-c[1], db=b-c[2], d=dr*dr+dg*dg+db*db;
        if (d<d1) { d2=d1; i2=i1; d1=d; i1=i; }
        else if (d<d2) { d2=d; i2=i; }
      });
      return [ palette[i1], palette[i2] ];
    }

    // DOM refs
    const uploadBtn     = document.getElementById('uploadBtn');
    const fileInput     = document.getElementById('fileInput');
    const sizeSelect    = document.getElementById('sizeSelect');
    const paletteSelect = document.getElementById('paletteSelect');
    const diag1Input    = document.getElementById('diag1Thresh');
    const diag2Input    = document.getElementById('diag2Thresh');
    const diag1Val      = document.getElementById('diag1Val');
    const diag2Val      = document.getElementById('diag2Val');
    const info          = document.getElementById('info');
    const output        = document.getElementById('output');

    let origPixels = null, origW = 0, origH = 0;

    // update slider labels & redraw
    function onSliderChange() {
      diag1Val.textContent = diag1Input.value;
      diag2Val.textContent = diag2Input.value;
      redraw();
    }
    diag1Input.addEventListener('input', onSliderChange);
    diag2Input.addEventListener('input', onSliderChange);

    // main redraw
    function redraw() {
      if (!origPixels) return;
      const maxSide = +sizeSelect.value;
      const scaledW = origW >= origH
        ? maxSide
        : Math.round(maxSide * origW / origH);
      const scaledH = origH > origW
        ? maxSide
        : Math.round(maxSide * origH / origW);

      const palRGB = palettes.Standard.map(hexToRgb);
      info.textContent = `Orig: ${origW}×${origH}px → ${scaledW}×${scaledH}px`;

      // error-diffusion buffers
      const errR = Array(scaledH).fill().map(()=>Array(scaledW).fill(0));
      const errG = Array(scaledH).fill().map(()=>Array(scaledW).fill(0));
      const errB = Array(scaledH).fill().map(()=>Array(scaledW).fill(0));

      // per-block data
      const prim  = [], sec  = [], errMag = [], orient = [];
      let maxErr = 0;
      const bw = origW / scaledW, bh = origH / scaledH;

      // first pass: average + quantize + diffuse
      for (let y=0; y<scaledH; y++) {
        prim[y]=[]; sec[y]=[]; errMag[y]=[]; orient[y]=[];
        for (let x=0; x<scaledW; x++) {
          let r=0,g=0,b=0,c=0;
          const x0=Math.floor(x*bw), y0=Math.floor(y*bh);
          const x1=Math.min(origW, Math.floor((x+1)*bw));
          const y1=Math.min(origH, Math.floor((y+1)*bh));
          for (let yy=y0; yy<y1; yy++) {
            for (let xx=x0; xx<x1; xx++) {
              const i=(yy*origW+xx)*4;
              r+=origPixels[i];
              g+=origPixels[i+1];
              b+=origPixels[i+2];
              c++;
            }
          }
          r = (c?r/c:0) + errR[y][x];
          g = (c?g/c:0) + errG[y][x];
          b = (c?b/c:0) + errB[y][x];
          [r,g,b] = [r,g,b].map(v=>Math.max(0,Math.min(255,v)));

          const [pcol,scol] = findTwoNearest(palRGB, r, g, b);
          const [pr,pg,pb] = pcol, [sr,sg,sb] = scol;
          const er=r-pr, eg=g-pg, eb=b-pb;
          // diffuse
          [[1,0,7/16],[-1,1,3/16],[0,1,5/16],[1,1,1/16]].forEach(([dx,dy,f])=>{
            const xx=x+dx, yy=y+dy;
            if(xx>=0&&xx<scaledW&&yy>=0&&yy<scaledH){
              errR[yy][xx] += er*f;
              errG[yy][xx] += eg*f;
              errB[yy][xx] += eb*f;
            }
          });

          prim[y][x]   = pcol;
          sec[y][x]    = scol;
          const m = Math.hypot(er, eg, eb);
          errMag[y][x] = m;
          if (m > maxErr) maxErr = m;
          orient[y][x] = Math.random()<0.5;
        }
      }

      // second pass: render with thresholds
      const t1 = +diag1Input.value, t2 = +diag2Input.value;
      const canvasOut = document.createElement('canvas');
      const blockSize = 8;
      canvasOut.width  = scaledW * blockSize;
      canvasOut.height = scaledH * blockSize;
      const ctx = canvasOut.getContext('2d');
      canvasOut.style.imageRendering = 'pixelated';

      for (let y=0; y<scaledH; y++) {
        for (let x=0; x<scaledW; x++) {
          const [pr,pg,pb] = prim[y][x];
          const [sr,sg,sb] = sec[y][x];
          const conf = errMag[y][x] / maxErr * 100;
          const px = x*blockSize, py = y*blockSize;
          ctx.fillStyle = `rgb(${pr},${pg},${pb})`;
          ctx.fillRect(px,py,blockSize,blockSize);
          ctx.strokeStyle = `rgb(${sr},${sg},${sb})`;
          ctx.lineWidth = 1;

          // higher conf → fewer stitches, so we invert:
          if (conf <= t1) {
            ctx.beginPath();
            if (orient[y][x]) {
              ctx.moveTo(px,py);
              ctx.lineTo(px+blockSize,py+blockSize);
            } else {
              ctx.moveTo(px,py+blockSize);
              ctx.lineTo(px+blockSize,py);
            }
            ctx.stroke();
            if (conf <= t2) {
              ctx.beginPath();
              if (orient[y][x]) {
                ctx.moveTo(px,py+blockSize);
                ctx.lineTo(px+blockSize,py);
              } else {
                ctx.moveTo(px,py);
                ctx.lineTo(px+blockSize,py+blockSize);
              }
              ctx.stroke();
            }
          }
        }
      }

      output.innerHTML = '';
      output.appendChild(canvasOut);
    }

    // events
    [sizeSelect, paletteSelect].forEach(el => el.addEventListener('change', redraw));
    uploadBtn.addEventListener('click', ()=>fileInput.click());
    fileInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if (!file || !file.type.startsWith('image/')) {
        return alert('Please select an image file.');
      }
      const reader = new FileReader();
      reader.onload = ev => {
        const img = new Image();
        img.onload = () => {
          origW = img.naturalWidth;
          origH = img.naturalHeight;
          const tmp = document.createElement('canvas');
          tmp.width = origW; tmp.height = origH;
          const tctx = tmp.getContext('2d');
          tctx.drawImage(img,0,0);
          origPixels = tctx.getImageData(0,0,origW,origH).data;
          redraw();
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    });
  </script>

</body>
</html>