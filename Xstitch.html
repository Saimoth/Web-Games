<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Xstitch</title>
  <style>
    body { font-family: sans-serif; text-align: center; padding: 1.5rem; background: #fafafa; color: #333; }
    h1 { margin-bottom: 1rem; }
    #controls, #slider1, #slider2, #slider3 { margin-bottom: 1rem; }
    button, select, input[type=range] {
      font-size: 1rem; padding: 0.4rem 0.8rem; margin-left: 0.3rem; vertical-align: middle;
    }
    label { font-size: 1rem; }
    #info { margin-top: 0.5rem; font-size: 0.9rem; color: #555; }
    #output {
      margin: 1rem auto; padding: 1rem; max-width: 90vw;
      background: #fff; border: 1px solid #ddd;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    #output canvas {
      width: 100%; height: auto; image-rendering: pixelated; display: block; margin: 0 auto;
    }
    #paletteGrid { margin-top: 1rem; }
    #grayscaleRow,#vibrantRow {
      display: flex; justify-content: center; margin-bottom: 0.5rem; flex-wrap: wrap;
    }
    .swatch {
      width: 30px; height: 30px; margin: 2px; border: 1px solid #ccc; box-sizing: border-box;
    }
  </style>
</head>
<body>

  <h1>Xstitch</h1>

  <div id="controls">
    <button id="uploadBtn">Choose Photo</button>
    <label>Size:
      <select id="sizeSelect">
        <option value="32">32</option>
        <option value="64">64</option>
        <option value="128" selected>128</option>
        <option value="256">256</option>
      </select>
    </label>
    <input type="file" id="fileInput" accept="image/*" style="display:none">
  </div>

  <div id="slider1">
    <label>Slash threshold:
      <input type="range" id="diag1Thresh" min="0" max="100" value="50">
      <span id="diag1Val">50</span>%
    </label>
  </div>

  <div id="slider2">
    <label>Cross threshold:
      <input type="range" id="diag2Thresh" min="0" max="100" value="25">
      <span id="diag2Val">25</span>%
    </label>
  </div>

  <div id="slider3">
    <label>Edge threshold:
      <input type="range" id="edgeThresh" min="0.00" max="0.80" step="0.01" value="0.30">
      <span id="edgeVal">0.30</span>
    </label>
  </div>

  <div id="info"></div>
  <div id="output"></div>
  <div id="paletteGrid">
    <div id="grayscaleRow"></div>
    <div id="vibrantRow"></div>
  </div>

  <script>
    // RGB â†’ HSL
    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h=0,s=0,l=(max+min)/2;
      if(max!==min){
        const d=max-min;
        s = l>0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          case b: h=(r-g)/d + 4; break;
        }
        h/=6;
      }
      return [h*360,s,l];
    }

    // k-means clustering
    function kmeans(pixels, k, iters=8) {
      const N = pixels.length, centroids = [], assign = new Array(N);
      for(let i=0;i<k;i++) centroids.push(pixels[Math.floor(Math.random()*N)].slice());
      for(let it=0; it<iters; it++){
        for(let i=0;i<N;i++){
          let best=0, bd=Infinity;
          for(let j=0;j<k;j++){
            const c=centroids[j],
                  dr=pixels[i][0]-c[0],
                  dg=pixels[i][1]-c[1],
                  db=pixels[i][2]-c[2],
                  d=dr*dr+dg*dg+db*db;
            if(d<bd){ bd=d; best=j; }
          }
          assign[i]=best;
        }
        const sums = Array.from({length:k}, ()=>[0,0,0,0]);
        for(let i=0;i<N;i++){
          const g=assign[i];
          sums[g][0]+=pixels[i][0];
          sums[g][1]+=pixels[i][1];
          sums[g][2]+=pixels[i][2];
          sums[g][3]++;
        }
        for(let j=0;j<k;j++){
          if(sums[j][3]>0){
            centroids[j] = [
              Math.round(sums[j][0]/sums[j][3]),
              Math.round(sums[j][1]/sums[j][3]),
              Math.round(sums[j][2]/sums[j][3])
            ];
          }
        }
      }
      return centroids;
    }

    // merge + dedupe palette
    function refinePalette(pal){
      const brightT=0.10*255, compT=0.15*255;
      for(let i=0;i<pal.length;i++){
        let [r1,g1,b1]=pal[i], br1=(r1+g1+b1)/3;
        for(let j=i+1;j<pal.length;){
          const [r2,g2,b2]=pal[j], br2=(r2+g2+b2)/3;
          if(Math.abs(br1-br2)<=brightT &&
             Math.abs(r1-r2)<=compT &&
             Math.abs(g1-g2)<=compT &&
             Math.abs(b1-b2)<=compT){
            const avg=[
              Math.round((r1+r2)/2),
              Math.round((g1+g2)/2),
              Math.round((b1+b2)/2)
            ];
            pal[i]=avg; [r1,g1,b1]=avg; br1=(avg[0]+avg[1]+avg[2])/3;
            pal.splice(j,1);
          } else j++;
        }
      }
      const deduped=[], globT=0.12*255;
      pal.forEach(c=>{
        if(!deduped.some(d=>{
          return Math.hypot(c[0]-d[0],c[1]-d[1],c[2]-d[2])<globT;
        })) deduped.push(c);
      });
      return deduped;
    }

    // extract 16-col palette
    function extractPalette(data){
      const pixels=[]; for(let i=0;i<data.length;i+=4) pixels.push([data[i],data[i+1],data[i+2]]);
      const satT=0.4, sat=pixels.filter(p=>rgbToHsl(...p)[1]>satT),
            satC=sat.length? kmeans(sat,Math.min(8,sat.length)) : [],
            remain=16-3-satC.length,
            unsat=pixels.filter(p=>rgbToHsl(...p)[1]<=satT),
            remC=(unsat.length&&remain>0)? kmeans(unsat,Math.min(remain,unsat.length)):[];
      let pal=[[0,0,0],[128,128,128],[255,255,255],...satC,...remC];
      pal.sort((a,b)=>(a[0]+a[1]+a[2])-(b[0]+b[1]+b[2]));
      return refinePalette(pal);
    }

    // find contrast colour
    function findContrastColour(base,pal){
      let best=pal[0], bd=-1;
      pal.forEach(c=>{
        const d=Math.hypot(c[0]-base[0],c[1]-base[1],c[2]-base[2]);
        if(d>bd){ bd=d; best=c; }
      });
      return best;
    }

    // DOM refs
    const uploadBtn=document.getElementById('uploadBtn'),
          fileInput=document.getElementById('fileInput'),
          sizeSelect=document.getElementById('sizeSelect'),
          d1Input=document.getElementById('diag1Thresh'),
          d2Input=document.getElementById('diag2Thresh'),
          edgeInput=document.getElementById('edgeThresh'),
          d1Val=document.getElementById('diag1Val'),
          d2Val=document.getElementById('diag2Val'),
          edgeVal=document.getElementById('edgeVal'),
          info=document.getElementById('info'),
          output=document.getElementById('output'),
          gsRow=document.getElementById('grayscaleRow'),
          vtRow=document.getElementById('vibrantRow');

    let origPixels, origW=0, origH=0, paletteRGB, origEdgeGx, origEdgeGy, origEdgeMag, origMaxG;

    d1Input.oninput=()=>{ d1Val.textContent=d1Input.value; redraw(); };
    d2Input.oninput=()=>{ d2Val.textContent=d2Input.value; redraw(); };
    edgeInput.oninput=()=>{ edgeVal.textContent=(+edgeInput.value).toFixed(2); redraw(); };

    uploadBtn.addEventListener('click',()=>fileInput.click());
    sizeSelect.addEventListener('change',redraw);

    fileInput.addEventListener('change',e=>{
      const f=e.target.files[0];
      if(!f||!f.type.startsWith('image/')) return alert('Select an image file.');
      const reader=new FileReader();
      reader.onload=ev=>{
        const img=new Image();
        img.onload=()=>{
          // shrink if largest side > 512
          let w=img.naturalWidth, h=img.naturalHeight;
          const maxAllowed=512, maxSide=Math.max(w,h);
          if(maxSide>maxAllowed){
            const scale=maxAllowed/maxSide;
            w=Math.round(w*scale);
            h=Math.round(h*scale);
          }
          origW=w; origH=h;
          const tmp=document.createElement('canvas');
          tmp.width=origW; tmp.height=origH;
          const tctx=tmp.getContext('2d');
          tctx.drawImage(img,0,0,origW,origH);
          const id=tctx.getImageData(0,0,origW,origH);
          origPixels=id.data;

          paletteRGB=extractPalette(origPixels);

          const lum=Array(origH).fill().map(()=>Array(origW).fill(0));
          origEdgeGx=Array(origH).fill().map(()=>Array(origW).fill(0));
          origEdgeGy=Array(origH).fill().map(()=>Array(origW).fill(0));
          origEdgeMag=Array(origH).fill().map(()=>Array(origW).fill(0));
          origMaxG=0;
          for(let y=0;y<origH;y++){
            for(let x=0;x<origW;x++){
              const i=(y*origW+x)*4;
              lum[y][x]=0.299*id.data[i]+0.587*id.data[i+1]+0.114*id.data[i+2];
            }
          }
          for(let y=1;y<origH-1;y++){
            for(let x=1;x<origW-1;x++){
              const gx=
                -lum[y-1][x-1]+lum[y-1][x+1]+
                -2*lum[y  ][x-1]+2*lum[y  ][x+1]+
                -lum[y+1][x-1]+lum[y+1][x+1];
              const gy=
                -lum[y-1][x-1]-2*lum[y-1][x]-lum[y-1][x+1]+
                 lum[y+1][x-1]+2*lum[y+1][x]+lum[y+1][x+1];
              const g=Math.hypot(gx,gy);
              origEdgeGx[y][x]=gx; origEdgeGy[y][x]=gy; origEdgeMag[y][x]=g;
              if(g>origMaxG) origMaxG=g;
            }
          }

          redraw();
        };
        img.src=ev.target.result;
      };
      reader.readAsDataURL(f);
    });

    function redraw(){
      if(!origPixels) return;
      const maxSide=+sizeSelect.value;
      const scaledW=origW>=origH?maxSide:Math.round(maxSide*origW/origH);
      const scaledH=origH>origW?maxSide:Math.round(maxSide*origH/origW);
      info.textContent=`${scaledW} x ${scaledH}`;

      const bw=origW/scaledW, bh=origH/scaledH;
      const errR=Array(scaledH).fill().map(()=>Array(scaledW).fill(0)),
            errG=Array(scaledH).fill().map(()=>Array(scaledW).fill(0)),
            errB=Array(scaledH).fill().map(()=>Array(scaledW).fill(0));
      const prim=[], sec=[], errMagArr=[], slashOri=[]; let maxErr=0;
      for(let y=0;y<scaledH;y++){
        prim[y]=[]; sec[y]=[]; errMagArr[y]=[]; slashOri[y]=[];
        for(let x=0;x<scaledW;x++){
          let r=0,g=0,b=0,c=0;
          const x0=Math.floor(x*bw), y0=Math.floor(y*bh),
                x1=Math.min(origW,Math.floor((x+1)*bw)),
                y1=Math.min(origH,Math.floor((y+1)*bh));
          for(let yy=y0;yy<y1;yy++){
            for(let xx=x0;xx<x1;xx++){
              const i=(yy*origW+xx)*4;
              r+=origPixels[i]; g+=origPixels[i+1]; b+=origPixels[i+2]; c++;
            }
          }
          r=(c?r/c:0)+errR[y][x];
          g=(c?g/c:0)+errG[y][x];
          b=(c?b/c:0)+errB[y][x];
          [r,g,b]=[r,g,b].map(v=>Math.max(0,Math.min(255,v)));

          let i1=0,i2=1,d1=Infinity,d2=Infinity;
          paletteRGB.forEach((col,i)=>{
            const dr=r-col[0], dg=g-col[1], db=b-col[2], d=dr*dr+dg*dg+db*db;
            if(d<d1){ d2=d1; i2=i1; d1=d; i1=i; }
            else if(d<d2){ d2=d; i2=i; }
          });
          prim[y][x]=paletteRGB[i1];
          sec[y][x]=paletteRGB[i2];

          const [pr,pg,pb]=prim[y][x], er=r-pr, eg=g-pg, eb=b-pb;
          [[1,0,7/16],[-1,1,3/16],[0,1,5/16],[1,1,1/16]].forEach(([dx,dy,f])=>{
            const xx=x+dx, yy=y+dy;
            if(xx>=0&&xx<scaledW&&yy>=0&&yy<scaledH){
              errR[yy][xx]+=er*f;
              errG[yy][xx]+=eg*f;
              errB[yy][xx]+=eb*f;
            }
          });
          const m=Math.hypot(er,eg,eb);
          errMagArr[y][x]=m; if(m>maxErr) maxErr=m;
          slashOri[y][x]=Math.random()<0.5;
        }
      }

      // map Sobel edges
      const edgeMul=+edgeInput.value;
      const hasEdge=Array(scaledH).fill().map(()=>Array(scaledW).fill(false));
      const gxSum=Array(scaledH).fill().map(()=>Array(scaledW).fill(0));
      const gySum=Array(scaledH).fill().map(()=>Array(scaledW).fill(0));
      const magSum=Array(scaledH).fill().map(()=>Array(scaledW).fill(0));
      for(let y=0;y<scaledH;y++){
        const y0=Math.floor(y*bh), y1=Math.min(origH,Math.floor((y+1)*bh));
        for(let x=0;x<scaledW;x++){
          const x0=Math.floor(x*bw), x1=Math.min(origW,Math.floor((x+1)*bw));
          let sGx=0,sGy=0,sM=0;
          for(let yy=y0;yy<y1;yy++){
            for(let xx=x0;xx<x1;xx++){
              const m=origEdgeMag[yy][xx];
              if(m>origMaxG*edgeMul) hasEdge[y][x]=true;
              sGx+=origEdgeGx[yy][xx]*m;
              sGy+=origEdgeGy[yy][xx]*m;
              sM+=m;
            }
          }
          gxSum[y][x]=sGx; gySum[y][x]=sGy; magSum[y][x]=sM;
        }
      }

      // gather candidates & keep top 50%
      const candidates=[];
      for(let y=0;y<scaledH;y++){
        for(let x=0;x<scaledW;x++){
          if(hasEdge[y][x]) candidates.push({x,y,sum:magSum[y][x]});
        }
      }
      candidates.sort((a,b)=>b.sum - a.sum);
      const idx = Math.floor(candidates.length * 0.5) - 1;
      const cutoff = candidates.length ? candidates[Math.max(0, idx)].sum : 0;
      const keepEdge = Array(scaledH).fill().map(()=>Array(scaledW).fill(false));
      candidates.forEach(c => {
        if(c.sum >= cutoff) keepEdge[c.y][c.x] = true;
      });

      // draw
      const bs = 8;
      const size = +sizeSelect.value;
      const minChunk = Math.max(1, Math.floor(size/16));
      const maxChunk = Math.max(1, Math.floor(size/4));
      const canvas = document.createElement('canvas'), ctx = canvas.getContext('2d');
      canvas.width = scaledW * bs; canvas.height = scaledH * bs;
      canvas.style.imageRendering = 'pixelated';
      const t1 = +d1Input.value, t2 = +d2Input.value;

      // stitches
      for(let y=0;y<scaledH;y++){
        for(let x=0;x<scaledW;x++){
          const [pr,pg,pb]=prim[y][x], [sr,sg,sb]=sec[y][x],
                conf=errMagArr[y][x]/maxErr*100,
                px=x*bs, py=y*bs;
          ctx.fillStyle=`rgb(${pr},${pg},${pb})`;
          ctx.fillRect(px,py,bs,bs);
          ctx.strokeStyle=`rgb(${sr},${sg},${sb})`;
          ctx.lineWidth=1;
          if(conf<t1){
            ctx.beginPath();
            if(slashOri[y][x]) ctx.moveTo(px,py),ctx.lineTo(px+bs,py+bs);
            else               ctx.moveTo(px,py+bs),ctx.lineTo(px+bs,py);
            ctx.stroke();
            if(conf<t2){
              ctx.beginPath();
              if(slashOri[y][x]) ctx.moveTo(px,py+bs),ctx.lineTo(px+bs,py);
              else               ctx.moveTo(px,py),    ctx.lineTo(px+bs,py+bs);
              ctx.stroke();
            }
          }
        }
      }

      // edge chunks
      const visited=Array(scaledH).fill().map(()=>Array(scaledW).fill(false));
      const dirs=[[-1,-1],[-1,0],[-1,1],[0,-1],[0,1],[1,-1],[1,0],[1,1]];
      for(let y=0;y<scaledH;y++){
        for(let x=0;x<scaledW;x++){
          if(!keepEdge[y][x]||visited[y][x]) continue;
          const stack=[[x,y]], comp=[]; visited[y][x]=true;
          while(stack.length){
            const [cx,cy]=stack.pop(); comp.push([cx,cy]);
            if(comp.length>=maxChunk) break;
            dirs.forEach(([dx,dy])=>{
              const nx=cx+dx, ny=cy+dy;
              if(nx>=0&&nx<scaledW&&ny>=0&&ny<scaledH&&keepEdge[ny][nx]&&!visited[ny][nx]){
                visited[ny][nx]=true; stack.push([nx,ny]);
              }
            });
          }
          if(comp.length<minChunk) continue;
          for(let i=0;i<comp.length;i+=maxChunk){
            const chunk=comp.slice(i,i+maxChunk);
            if(chunk.length<minChunk) break;
            const [sx,sy]=chunk[0];
            const ccol=findContrastColour(prim[sy][sx],paletteRGB);
            ctx.strokeStyle=`rgb(${ccol[0]},${ccol[1]},${ccol[2]})`;
            ctx.lineWidth=2;
            ctx.beginPath();
            ctx.moveTo(chunk[0][0]*bs+bs/2,chunk[0][1]*bs+bs/2);
            for(let j=1;j<chunk.length;j++){
              ctx.lineTo(chunk[j][0]*bs+bs/2,chunk[j][1]*bs+bs/2);
            }
            ctx.stroke();
          }
        }
      }

      output.innerHTML=''; output.appendChild(canvas);

      // palette swatches
      const half=Math.ceil(paletteRGB.length/2),
            row1=paletteRGB.slice(0,half),
            row2=paletteRGB.slice(half);
      gsRow.innerHTML=''; vtRow.innerHTML='';
      row1.forEach(c=>{
        const d=document.createElement('div');
        d.className='swatch';
        d.style.background=`rgb(${c[0]},${c[1]},${c[2]})`;
        gsRow.appendChild(d);
      });
      row2.forEach(c=>{
        const d=document.createElement('div');
        d.className='swatch';
        d.style.background=`rgb(${c[0]},${c[1]},${c[2]})`;
        vtRow.appendChild(d);
      });
    }
  </script>
</body>
</html>
