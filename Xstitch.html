<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Xstitch</title>
  <style>
    body {
      font-family: sans-serif;
      text-align: center;
      padding: 1.5rem;
      background: #fafafa;
      color: #333;
    }
    h1 {
      margin-bottom: 1rem;
    }
    #controls, #slider1, #slider2 {
      margin-bottom: 1rem;
    }
    button, select, input[type=range] {
      font-size: 1rem;
      padding: 0.4rem 0.8rem;
      margin-left: 0.3rem;
      vertical-align: middle;
    }
    label {
      font-size: 1rem;
    }
    #info {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #555;
    }
    #output {
      margin: 1rem auto;
      padding: 1rem;
      max-width: 90vw;
      background: #fff;
      border: 1px solid #ddd;
      box-shadow: 0 2px 4px rgba(0,0,0,0.05);
    }
    #output canvas {
      width: 100%;
      height: auto;
      image-rendering: pixelated;
      display: block;
      margin: 0 auto;
    }
    #paletteGrid {
      margin-top: 1rem;
    }
    #grayscaleRow, #vibrantRow {
      display: flex;
      justify-content: center;
      margin-bottom: 0.5rem;
      flex-wrap: wrap;
    }
    .swatch {
      width: 30px;
      height: 30px;
      margin: 2px;
      border: 1px solid #ccc;
      box-sizing: border-box;
    }
  </style>
</head>
<body>

  <h1>Xstitch</h1>

  <div id="controls">
    <button id="uploadBtn">Upload Photo</button>
    <label>
      Scale:
      <select id="sizeSelect">
        <option value="32">32</option>
        <option value="64">64</option>
        <option value="128" selected>128</option>
        <option value="256">256</option>
      </select>
    </label>
    <input type="file" id="fileInput" accept="image/*" style="display:none">
  </div>

  <div id="slider1">
    <label>
      Slash threshold:
      <input type="range" id="diag1Thresh" min="0" max="100" value="80">
      <span id="diag1Val">80</span>%
    </label>
  </div>

  <div id="slider2">
    <label>
      Cross threshold:
      <input type="range" id="diag2Thresh" min="0" max="100" value="50">
      <span id="diag2Val">50</span>%
    </label>
  </div>

  <div id="info"></div>
  <div id="output"></div>
  <div id="paletteGrid">
    <div id="grayscaleRow"></div>
    <div id="vibrantRow"></div>
  </div>

  <script>
    // Convert RGB to HSL
    function rgbToHsl(r,g,b){
      r/=255; g/=255; b/=255;
      const max=Math.max(r,g,b), min=Math.min(r,g,b);
      let h=0, s=0, l=(max+min)/2;
      if(max!==min){
        const d=max-min;
        s = l>0.5 ? d/(2-max-min) : d/(max+min);
        switch(max){
          case r: h=(g-b)/d + (g<b?6:0); break;
          case g: h=(b-r)/d + 2; break;
          case b: h=(r-g)/d + 4; break;
        }
        h/=6;
      }
      return [h*360, s, l];
    }

    // Find two nearest palette colours
    function findTwoNearest(palette, r,g,b){
      let i1=0, i2=1, d1=Infinity, d2=Infinity;
      palette.forEach((c,i)=>{
        const dr=r-c[0], dg=g-c[1], db=b-c[2];
        const d = dr*dr + dg*dg + db*db;
        if(d < d1){ d2=d1; i2=i1; d1=d; i1=i; }
        else if(d < d2){ d2=d; i2=i; }
      });
      return [palette[i1], palette[i2]];
    }

    // Extract a minimalist palette:
    // always include black, mid grey, white,
    // then up to 7 vibrant colours
    function extractPalette(data){
      // sample pixels sparsely
      const sample = [];
      for(let i=0; i<data.length; i+=50*4){
        sample.push([data[i], data[i+1], data[i+2]]);
      }

      // k-means for 12 clusters
      const k=12, iters=8;
      let centroids = Array.from({length:k},
        ()=> sample[Math.floor(Math.random()*sample.length)]
      );
      for(let it=0; it<iters; it++){
        const clusters = Array.from({length:k}, ()=>[]);
        sample.forEach(p=>{
          let best=0, bd=Infinity;
          centroids.forEach((c,i)=>{
            const dr=p[0]-c[0], dg=p[1]-c[1], db=p[2]-c[2];
            const d = dr*dr+dg*dg+db*db;
            if(d<bd){ bd=d; best=i; }
          });
          clusters[best].push(p);
        });
        centroids = centroids.map((c,i)=>{
          const cl=clusters[i];
          if(!cl.length) return c;
          const sum=cl.reduce((a,p)=>[a[0]+p[0],a[1]+p[1],a[2]+p[2]],[0,0,0]);
          return sum.map(v=>Math.round(v/cl.length));
        });
      }

      // split grey vs vibrant
      const grayThresh = 0.2;
      const vibrant = [], greys = [];
      centroids.forEach(c=>{
        const [,s,] = rgbToHsl(c[0],c[1],c[2]);
        if(s < grayThresh) greys.push(c);
        else vibrant.push(c);
      });

      // sort vibrant by hue, limit to 7
      vibrant.sort((a,b)=>
        rgbToHsl(a[0],a[1],a[2])[0] - rgbToHsl(b[0],b[1],b[2])[0]
      );
      const vibrantTrimmed = vibrant.slice(0, 7);

      // final palette: black, mid grey, white, then vibrant
      const black = [0,0,0];
      const mid   = [128,128,128];
      const white = [255,255,255];
      return [black, mid, white, ...vibrantTrimmed];
    }

    // DOM refs
    const uploadBtn   = document.getElementById('uploadBtn');
    const fileInput   = document.getElementById('fileInput');
    const sizeSelect  = document.getElementById('sizeSelect');
    const d1Input     = document.getElementById('diag1Thresh');
    const d2Input     = document.getElementById('diag2Thresh');
    const d1Val       = document.getElementById('diag1Val');
    const d2Val       = document.getElementById('diag2Val');
    const info        = document.getElementById('info');
    const output      = document.getElementById('output');
    const gsRow       = document.getElementById('grayscaleRow');
    const vtRow       = document.getElementById('vibrantRow');

    let origPixels=null, origW=0, origH=0, paletteRGB=[];

    // update slider labels & redraw
    function onSliderChange(){
      d1Val.textContent = d1Input.value;
      d2Val.textContent = d2Input.value;
      redraw();
    }
    d1Input.addEventListener('input', onSliderChange);
    d2Input.addEventListener('input', onSliderChange);

    // redraw function
    function redraw(){
      if(!origPixels) return;
      const maxSide = +sizeSelect.value;
      const scaledW = origW>=origH
        ? maxSide
        : Math.round(maxSide*origW/origH);
      const scaledH = origH>origW
        ? maxSide
        : Math.round(maxSide*origH/origW);
      info.textContent = `Orig: ${origW}×${origH}px → ${scaledW}×${scaledH}px`;

      // error buffers
      const errR = Array(scaledH).fill().map(()=>Array(scaledW).fill(0));
      const errG = Array(scaledH).fill().map(()=>Array(scaledW).fill(0));
      const errB = Array(scaledH).fill().map(()=>Array(scaledW).fill(0));

      // per-block storage
      const prim=[], sec=[], errMag=[], orient=[];
      let maxErr=0;
      const bw=origW/scaledW, bh=origH/scaledH;

      for(let y=0; y<scaledH; y++){
        prim[y]=[]; sec[y]=[]; errMag[y]=[]; orient[y]=[];
        for(let x=0; x<scaledW; x++){
          let r=0,g=0,b=0,c=0;
          const x0=Math.floor(x*bw), y0=Math.floor(y*bh);
          const x1=Math.min(origW, Math.floor((x+1)*bw));
          const y1=Math.min(origH, Math.floor((y+1)*bh));
          for(let yy=y0; yy<y1; yy++){
            for(let xx=x0; xx<x1; xx++){
              const i=(yy*origW+xx)*4;
              r+=origPixels[i];
              g+=origPixels[i+1];
              b+=origPixels[i+2];
              c++;
            }
          }
          r = (c?r/c:0) + errR[y][x];
          g = (c?g/c:0) + errG[y][x];
          b = (c?b/c:0) + errB[y][x];
          [r,g,b] = [r,g,b].map(v=>Math.max(0,Math.min(255,v)));

          const [pcol,scol] = findTwoNearest(paletteRGB, r,g,b);
          const [pr,pg,pb] = pcol, [sr,sg,sb] = scol;
          const er=r-pr, eg=g-pg, eb=b-pb;
          [[1,0,7/16],[-1,1,3/16],[0,1,5/16],[1,1,1/16]].forEach(([dx,dy,f])=>{
            const xx=x+dx, yy=y+dy;
            if(xx>=0&&xx<scaledW&&yy>=0&&yy<scaledH){
              errR[yy][xx]+=er*f;
              errG[yy][xx]+=eg*f;
              errB[yy][xx]+=eb*f;
            }
          });

          prim[y][x]=pcol;
          sec[y][x]=scol;
          const m = Math.hypot(er,eg,eb);
          errMag[y][x]=m;
          if(m>maxErr) maxErr=m;
          orient[y][x]=Math.random()<0.5;
        }
      }

      // draw to canvas
      const t1=+d1Input.value, t2=+d2Input.value;
      const canvasOut=document.createElement('canvas');
      const bs=8;
      canvasOut.width=scaledW*bs;
      canvasOut.height=scaledH*bs;
      const ctx=canvasOut.getContext('2d');
      canvasOut.style.imageRendering='pixelated';

      for(let y=0; y<scaledH; y++){
        for(let x=0; x<scaledW; x++){
          const [pr,pg,pb]=prim[y][x];
          const [sr,sg,sb]=sec[y][x];
          const conf=errMag[y][x]/maxErr*100;
          const px=x*bs, py=y*bs;
          ctx.fillStyle=`rgb(${pr},${pg},${pb})`;
          ctx.fillRect(px,py,bs,bs);
          ctx.strokeStyle=`rgb(${sr},${sg},${sb})`;
          ctx.lineWidth=1;

          if(conf < t1){
            ctx.beginPath();
            if(orient[y][x]){
              ctx.moveTo(px,py);
              ctx.lineTo(px+bs,py+bs);
            } else {
              ctx.moveTo(px,py+bs);
              ctx.lineTo(px+bs,py);
            }
            ctx.stroke();
            if(conf < t2){
              ctx.beginPath();
              if(orient[y][x]){
                ctx.moveTo(px,py+bs);
                ctx.lineTo(px+bs,py);
              } else {
                ctx.moveTo(px,py);
                ctx.lineTo(px+bs,py+bs);
              }
              ctx.stroke();
            }
          }
        }
      }

      output.innerHTML=''; 
      output.appendChild(canvasOut);

      // display palette
      const grayscale = paletteRGB.slice(0,3);  // black, mid, white
      const vibrant   = paletteRGB.slice(3);
      gsRow.innerHTML=''; vtRow.innerHTML='';
      grayscale.forEach(c=>{
        const d=document.createElement('div');
        d.className='swatch';
        d.style.background=`rgb(${c[0]},${c[1]},${c[2]})`;
        gsRow.appendChild(d);
      });
      vibrant.forEach(c=>{
        const d=document.createElement('div');
        d.className='swatch';
        d.style.background=`rgb(${c[0]},${c[1]},${c[2]})`;
        vtRow.appendChild(d);
      });
    }

    // file load & events
    uploadBtn.addEventListener('click',()=>fileInput.click());
    fileInput.addEventListener('change',e=>{
      const f=e.target.files[0];
      if(!f||!f.type.startsWith('image/')) return alert('Select an image file.');
      const reader=new FileReader();
      reader.onload=ev=>{
        const img=new Image();
        img.onload=()=>{
          origW=img.naturalWidth; origH=img.naturalHeight;
          const tmp=document.createElement('canvas');
          tmp.width=origW; tmp.height=origH;
          const tctx=tmp.getContext('2d');
          tctx.drawImage(img,0,0);
          origPixels=tctx.getImageData(0,0,origW,origH).data;
          paletteRGB=extractPalette(origPixels);
          redraw();
        };
        img.src=ev.target.result;
      };
      reader.readAsDataURL(f);
    });
    sizeSelect.addEventListener('change', redraw);
  </script>

</body>
</html>