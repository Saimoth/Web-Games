<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Logic Lab: Circuit Simulator</title>
    <style>
        :root {
            --bg-color: #2c2c2c; 
            --sidebar-bg: #16213e;
            --text-color: #e94560;
            --accent: #0f3460;
            --wire-off: #53354a;
            --wire-on: #00ff9d;
            --panel-bg: #252a40;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: white;
            display: flex;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Sidebar Styling */
        #sidebar {
            width: 260px;
            background-color: var(--sidebar-bg);
            display: flex;
            flex-direction: column;
            border-right: 2px solid var(--accent);
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .logo {
            padding: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text-color);
            text-align: center;
            border-bottom: 1px solid var(--accent);
        }

        .tools-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .category-label {
            font-size: 0.8rem;
            text-transform: uppercase;
            color: #888;
            margin-top: 15px;
            margin-bottom: 5px;
            padding-left: 5px;
        }

        .tool-item {
            background-color: var(--accent);
            margin-bottom: 8px;
            padding: 10px;
            border-radius: 8px;
            cursor: grab;
            display: flex;
            align-items: center;
            transition: transform 0.1s, background 0.2s;
        }

        .tool-item:hover {
            background-color: #1a4a80;
            transform: translateX(5px);
        }

        .tool-item:active {
            cursor: grabbing;
        }

        .tool-icon {
            width: 30px;
            height: 30px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Bottom Controls */
        .controls {
            padding: 15px;
            border-top: 1px solid var(--accent);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .btn-group {
            display: flex;
            gap: 5px;
        }

        button {
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.2s;
            flex: 1;
        }

        .btn-clear { background-color: #e94560; color: white; }
        .btn-help { background-color: #0f3460; color: white; }
        .btn-save { background-color: var(--wire-on); color: #000; }
        .btn-load { background-color: #d35400; color: white; }
        .btn-cancel { background-color: #555; color: white; }

        button:hover { opacity: 0.8; }

        /* Canvas Area */
        #canvas-container {
            flex: 1;
            position: relative;
            background-color: var(--bg-color);
            overflow: hidden;
            cursor: crosshair;
        }

        canvas { display: block; }

        /* Context Menu (Config Panel) */
        #configPanel {
            display: none;
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: var(--panel-bg);
            border: 1px solid var(--accent);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 200;
            min-width: 250px;
            color: white;
        }

        #configPanel h3 {
            margin-top: 0;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            font-size: 1rem;
        }

        .config-row { margin-bottom: 15px; }
        .config-label { display: block; margin-bottom: 5px; font-size: 0.9rem; color: #aaa; }
        input[type="range"] { width: 100%; }

        .radio-group {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }

        .radio-label {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            cursor: pointer;
        }
        .radio-label input { margin-right: 8px; }
        
        .panel-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

        /* Hidden File Input */
        #fileInput { display: none; }

        /* Modal styling */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: var(--sidebar-bg);
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            line-height: 1.6;
            color: #ddd;
        }
        .close-modal { float: right; cursor: pointer; font-size: 20px; }

    </style>
</head>
<body>

    <!-- Sidebar Tools -->
    <div id="sidebar">
        <div class="logo">âš¡ Logic Lab</div>
        
        <div class="tools-container">
            <div class="category-label">Inputs</div>
            <div class="tool-item" draggable="true" data-type="SWITCH">
                <div class="tool-icon" style="background:#4a90e2">SW</div>
                <span>Toggle Switch</span>
            </div>
            <div class="tool-item" draggable="true" data-type="PUSH_BTN">
                <div class="tool-icon" style="background:#27ae60; color:white">PB</div>
                <span>Push Button</span>
            </div>
            <div class="tool-item" draggable="true" data-type="CLOCK">
                <div class="tool-icon" style="background:#34495e; color:white">CLK</div>
                <span>Clock Gen</span>
            </div>
            
            <div class="category-label">LEDs</div>
            <!-- Small circular LED icons -->
            <div style="display:flex; flex-wrap:wrap; gap:5px; padding-left:5px;">
                <div class="tool-item" draggable="true" data-type="LED_R" style="width:30px; padding:5px;" title="Red"><div class="tool-icon" style="background:#e74c3c; margin:0; border-radius:50%;"></div></div>
                <div class="tool-item" draggable="true" data-type="LED_O" style="width:30px; padding:5px;" title="Orange"><div class="tool-icon" style="background:#e67e22; margin:0; border-radius:50%;"></div></div>
                <div class="tool-item" draggable="true" data-type="LED_Y" style="width:30px; padding:5px;" title="Yellow"><div class="tool-icon" style="background:#f1c40f; margin:0; border-radius:50%;"></div></div>
                <div class="tool-item" draggable="true" data-type="LED_G" style="width:30px; padding:5px;" title="Green"><div class="tool-icon" style="background:#2ecc71; margin:0; border-radius:50%;"></div></div>
                <div class="tool-item" draggable="true" data-type="LED_B" style="width:30px; padding:5px;" title="Blue"><div class="tool-icon" style="background:#3498db; margin:0; border-radius:50%;"></div></div>
                <div class="tool-item" draggable="true" data-type="LED_P" style="width:30px; padding:5px;" title="Purple"><div class="tool-icon" style="background:#9b59b6; margin:0; border-radius:50%;"></div></div>
                <div class="tool-item" draggable="true" data-type="LED_W" style="width:30px; padding:5px;" title="White"><div class="tool-icon" style="background:#ffffff; margin:0; border-radius:50%;"></div></div>
            </div>

            <div class="category-label">Complex Output</div>
            <div class="tool-item" draggable="true" data-type="SEVEN_SEG">
                <div class="tool-icon" style="background:#000; color:red; border:1px solid #444;">8.</div>
                <span>7-Seg Display</span>
            </div>

            <div class="category-label">Logic Gates</div>
            <div class="tool-item" draggable="true" data-type="AND">
                <div class="tool-icon" style="background:#50e3c2; color:black">AND</div>
                <span>AND Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="OR">
                <div class="tool-icon" style="background:#b8e986; color:black">OR</div>
                <span>OR Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="NOT">
                <div class="tool-icon" style="background:#bd10e0; color:white">NOT</div>
                <span>NOT Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="XOR">
                <div class="tool-icon" style="background:#9013fe; color:white">XOR</div>
                <span>XOR Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="LATCH">
                <div class="tool-icon" style="background:#d35400; color:white">SR</div>
                <span>SR Latch</span>
            </div>
            <div class="tool-item" draggable="true" data-type="RS_LATCH">
                <div class="tool-icon" style="background:#d35400; color:white">RS</div>
                <span>RS Latch</span>
            </div>

            <div class="category-label">Advanced</div>
            <div class="tool-item" draggable="true" data-type="SHIFT_REG">
                <div class="tool-icon" style="background:#8e44ad; color:white">SR8</div>
                <span>Shift Reg (8)</span>
            </div>
            <div class="tool-item" draggable="true" data-type="TON">
                <div class="tool-icon" style="background:#417505; color:white">TON</div>
                <span>Timer ON</span>
            </div>
            <div class="tool-item" draggable="true" data-type="TOF">
                <div class="tool-icon" style="background:#d0021b; color:white">TOF</div>
                <span>Timer OFF</span>
            </div>
        </div>

        <div class="controls">
            <div style="font-size: 0.75rem; color:#888; text-align:center; margin-bottom:5px;">
                <strong>Double Right-Click</strong> Comp to Delete.<br>
                <strong>Right-Click</strong> to Configure.<br>
                Drag BG to Pan.
            </div>
            <div class="btn-group">
                <button class="btn-save" onclick="saveProject()">Save</button>
                <button class="btn-load" onclick="document.getElementById('fileInput').click()">Load</button>
            </div>
            <button class="btn-clear" onclick="clearBoard()">Clear Board</button>
            <button class="btn-help" onclick="toggleHelp()">How to Play</button>
            <input type="file" id="fileInput" accept=".json" onchange="loadProject(this)">
        </div>
    </div>

    <!-- Main Canvas -->
    <div id="canvas-container">
        <canvas id="circuitCanvas"></canvas>
        
        <!-- Context Menu / Config Panel -->
        <div id="configPanel">
            <h3 id="configTitle">Settings</h3>
            
            <!-- Timers/Clock -->
            <div id="timerControls">
                <div class="config-row">
                    <div class="config-label">Period/Duration: <span id="valDisplay" style="color:var(--wire-on); font-weight:bold;">0.5</span></div>
                    <input type="range" id="timerSlider" min="0" max="1" step="0.01" value="0.5" oninput="updateValDisplay(this.value)">
                </div>
                
                <div class="config-row" id="dutyRow" style="display:none;">
                    <div class="config-label">Duty Cycle %: <span id="dutyDisplay" style="color:var(--wire-on); font-weight:bold;">50</span></div>
                    <input type="range" id="dutySlider" min="0" max="100" step="5" value="50" oninput="updateDutyDisplay(this.value)">
                </div>

                <div class="config-row">
                    <div class="config-label">Time Base</div>
                    <div class="radio-group">
                        <label class="radio-label"><input type="radio" name="timebase" value="1" checked> 1s</label>
                        <label class="radio-label"><input type="radio" name="timebase" value="10"> 10s</label>
                        <label class="radio-label"><input type="radio" name="timebase" value="100"> 100s</label>
                    </div>
                </div>
            </div>

            <!-- Gate/LED Inputs -->
            <div id="inputCountControls" style="display:none;">
                <div class="config-row">
                    <div class="config-label">Count / Inputs: <span id="inputCountDisplay" style="color:var(--wire-on); font-weight:bold;">2</span></div>
                    <input type="range" id="inputCountSlider" min="1" max="8" step="1" value="2" oninput="updateInputCountDisplay(this.value)">
                </div>
            </div>

            <div class="panel-actions">
                <button class="btn-cancel" onclick="closeConfig()">Cancel</button>
                <button class="btn-save" onclick="saveConfig()">Apply</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="toggleHelp()">&times;</span>
            <h2>How to Use Logic Lab</h2>
            <p>1. <strong>Wiring:</strong> Drag from Circle (Out) to Square (In).</p>
            <p>2. <strong>Config:</strong> Right-Click a Gate or LED to change count (1-8).</p>
            <p>3. <strong>LEDs:</strong> Dim color = OFF, Bright Neon = ON.</p>
            <p>4. <strong>Controls:</strong>
                <br>- Double Right-Click Component: Delete
                <br>- Right-Click Pin: Clear Wires
                <br>- Drag Background: Pan View
                <br>- Save/Load: Keep your projects locally.
            </p>
        </div>
    </div>

<script>
/**
 * ENGINE CONSTANTS
 */
const GRID_SIZE = 20;
const WIRE_COLOR_OFF = '#53354a';
const WIRE_COLOR_ON = '#00ff9d';
const SNAP_DIST = 15;
const FPS = 60;
const SUB_STEPS = 4; 

/**
 * STATE MANAGEMENT
 */
const canvas = document.getElementById('circuitCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');

// View State
let viewX = 0;
let viewY = 0;
let isPanning = false;
let panStart = { x: 0, y: 0 };

let components = [];
let wires = []; 

let draggingComponent = null;
let dragOffset = { x: 0, y: 0 };
let isDraggingComp = false; 
let dragStartPos = {x:0, y:0};
let pressedButtonId = null; 

let wiringStart = null; 
let mousePos = { x: 0, y: 0 };

// Config Panel State
let editingComponent = null;

// Double Right Click Logic
let lastRightClickTime = 0;
let lastRightClickId = null;

/**
 * COMPONENT DEFINITIONS & FACTORY
 */
const LED_PALETTE = {
    LED_R: { on: '#ff0000', off: '#440000', label: 'RED' },
    LED_O: { on: '#ff7f00', off: '#442200', label: 'ORG' },
    LED_Y: { on: '#ffff00', off: '#444400', label: 'YEL' },
    LED_G: { on: '#00ff00', off: '#004400', label: 'GRN' },
    LED_B: { on: '#0055ff', off: '#001144', label: 'BLU' },
    LED_P: { on: '#aa00ff', off: '#330044', label: 'PUR' },
    LED_W: { on: '#ffffff', off: '#444444', label: 'WHT' },
};

const COMP_DEFS = {
    // Inputs
    SWITCH:    { w: 60, inputs: 0, outputs: 1, color: '#4a90e2', label: 'SW' },
    PUSH_BTN:  { w: 60, inputs: 0, outputs: 1, color: '#27ae60', label: 'PB' },
    CLOCK:     { w: 60, inputs: 0, outputs: 1, color: '#34495e', label: 'CLK' },
    
    // Gates (Default 2 inputs, Resizable)
    AND:       { w: 60, inputs: 2, outputs: 1, color: '#50e3c2', label: 'AND', textColor: 'black', resizable: true },
    OR:        { w: 60, inputs: 2, outputs: 1, color: '#b8e986', label: 'OR', textColor: 'black', resizable: true },
    NOT:       { w: 60, inputs: 1, outputs: 1, color: '#bd10e0', label: 'NOT', textColor: 'white' },
    XOR:       { w: 60, inputs: 2, outputs: 1, color: '#9013fe', label: 'XOR', resizable: true },
    
    // Latches
    LATCH:     { w: 60, inputs: 2, outputs: 1, color: '#d35400', label: 'SR' }, 
    RS_LATCH:  { w: 60, inputs: 2, outputs: 1, color: '#d35400', label: 'RS' }, 
    
    // Complex
    SHIFT_REG: { w: 100, inputs: 3, outputs: 8, color: '#8e44ad', label: 'SHIFT' },
    SEVEN_SEG: { w: 90, inputs: 8, outputs: 0, color: '#000000', label: '' }, 
    TON:       { w: 60, inputs: 1, outputs: 1, color: '#417505', label: 'TON' }, 
    TOF:       { w: 60, inputs: 1, outputs: 1, color: '#d0021b', label: 'TOF' }, 
};

class Component {
    constructor(type, x, y, inputCountOverride) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.type = type;
        
        // Is it an LED?
        this.isLed = LED_PALETTE[type] !== undefined;
        // LEDs allow resizing (multistrip)
        this.def = this.isLed ? { w:20, inputs:1, outputs:0, resizable:true } : COMP_DEFS[type];
        
        this.x = x;
        this.y = y;
        this.w = this.def.w;
        
        // Initialize Inputs/Outputs based on definition or override
        let initialInputs = this.def.inputs;
        if (inputCountOverride) initialInputs = inputCountOverride;
        
        this.inputStates = new Array(initialInputs).fill(false);
        this.outputStates = new Array(this.def.outputs).fill(false);
        
        // Calculate Height Dynamically
        this.resize();

        // Internal State
        this.timerValue = 0; 
        this.timeSetting = 0.5; 
        this.timeBase = 1.0; 
        this.dutyCycle = 50; 
        this.updateTimerLimit();
        this.prevClockState = false;
    }

    resize() {
        // Height calculation: 20px per max(input, output). Min 40px (2 units)
        const maxPins = Math.max(this.inputStates.length, this.outputStates.length);
        
        if (this.isLed) {
            // LEDs scale precisely with count
            this.h = Math.max(20, this.inputStates.length * 20);
        } else if (this.type === 'SEVEN_SEG') {
            this.h = 180; // Fixed height
        } else {
            this.h = Math.max(40, maxPins * 20);
        }
    }

    updateConfig(config) {
        if (config.timeSetting) this.timeSetting = parseFloat(config.timeSetting);
        if (config.timeBase) this.timeBase = parseFloat(config.timeBase);
        if (config.dutyCycle) this.dutyCycle = parseInt(config.dutyCycle);
        
        if (config.inputCount && this.def.resizable) {
            const count = parseInt(config.inputCount);
            // Resize input array preserving existing states
            const newInputs = new Array(count).fill(false);
            for(let i=0; i<Math.min(this.inputStates.length, count); i++) {
                newInputs[i] = this.inputStates[i];
            }
            this.inputStates = newInputs;
            this.resize();
        }
        this.updateTimerLimit();
    }

    updateTimerLimit() {
        this.timerLimit = Math.max(1, Math.round(this.timeSetting * this.timeBase * FPS * SUB_STEPS));
    }

    // Logic Update Tick
    update() {
        if (this.type === 'AND') this.outputStates[0] = this.inputStates.every(Boolean);
        else if (this.type === 'OR') this.outputStates[0] = this.inputStates.some(Boolean);
        else if (this.type === 'NOT') this.outputStates[0] = !this.inputStates[0];
        else if (this.type === 'XOR') {
            // Inequality Logic: Output ON only if inputs are mixed (not all ON and not all OFF)
            // 2-Input: Equivalent to standard XOR
            // >2 Input: Returns true if any input differs from the others
            const allOn = this.inputStates.every(Boolean);
            const allOff = this.inputStates.every(s => !s);
            this.outputStates[0] = !(allOn || allOff);
        }
        
        else if (this.type === 'LATCH') { 
            if (this.inputStates[0]) this.outputStates[0] = true;
            else if (this.inputStates[1]) this.outputStates[0] = false;
        } else if (this.type === 'RS_LATCH') { 
            if (this.inputStates[0]) this.outputStates[0] = false;
            else if (this.inputStates[1]) this.outputStates[0] = true;
        } 
        
        else if (this.isLed) {
            // Visual only, no output logic change needed, state resides in inputStates
        } 
        
        else if (this.type === 'TON') {
            if (this.inputStates[0]) {
                if (this.timerValue < this.timerLimit) this.timerValue++;
            } else {
                this.timerValue = 0;
            }
            this.outputStates[0] = (this.timerValue >= this.timerLimit);
        } else if (this.type === 'TOF') {
            if (this.inputStates[0]) {
                this.outputStates[0] = true;
                this.timerValue = this.timerLimit;
            } else {
                if (this.timerValue > 0) {
                    this.timerValue--;
                    this.outputStates[0] = true;
                } else {
                    this.outputStates[0] = false;
                }
            }
        } 
        
        else if (this.type === 'CLOCK') {
            this.timerValue++;
            if (this.timerValue >= this.timerLimit) this.timerValue = 0;
            const threshold = (this.dutyCycle / 100) * this.timerLimit;
            this.outputStates[0] = (this.timerValue < threshold);
        }

        else if (this.type === 'SHIFT_REG') {
            const data = this.inputStates[0];
            const clk = this.inputStates[1];
            const rst = this.inputStates[2];
            if (rst) {
                this.outputStates.fill(false);
            } else if (clk && !this.prevClockState) {
                for (let i = 7; i > 0; i--) this.outputStates[i] = this.outputStates[i-1];
                this.outputStates[0] = data;
            }
            this.prevClockState = clk;
        }
    }

    getInputPos(index) {
        // LED Input Connector Shifted 5px Left
        const xOff = this.isLed ? -5 : 0;
        return { x: this.x + xOff, y: this.y + (index * 20) + 10 };
    }

    getOutputPos(index) {
        return { x: this.x + this.w, y: this.y + (index * 20) + 10 };
    }

    draw(ctx) {
        let fillColor = this.def.color;
        
        if (this.type === 'PUSH_BTN' && this.outputStates[0]) fillColor = '#2ecc71';

        ctx.fillStyle = fillColor;
        
        if (this === draggingComponent) {
            ctx.shadowColor = 'rgba(255,255,255,0.5)';
            ctx.shadowBlur = 10;
        }

        // Draw Body
        if (this.isLed) {
            // Draw possibly multiple LEDs vertically
            const colors = LED_PALETTE[this.type];
            for (let i = 0; i < this.inputStates.length; i++) {
                const on = this.inputStates[i];
                ctx.fillStyle = on ? colors.on : colors.off;
                ctx.beginPath();
                ctx.arc(this.x + 10, this.y + (i * 20) + 10, 8, 0, Math.PI*2);
                ctx.fill();
                if (on) {
                    ctx.shadowColor = colors.on;
                    ctx.shadowBlur = 15;
                    ctx.fill(); 
                    ctx.shadowBlur = 0;
                }
            }
        } else {
            // Draw Block
            roundRect(ctx, this.x, this.y, this.w, this.h, 6);
            ctx.fill();
        }
        ctx.shadowBlur = 0;

        // Label (Top Header)
        if (!this.isLed) {
            ctx.fillStyle = this.def.textColor || 'white';
            ctx.font = "bold 14px sans-serif";
            ctx.textAlign = "center";
            ctx.textBaseline = "top";
            
            if (this.type === 'TON' || this.type === 'TOF' || this.type === 'CLOCK') {
                let pct = this.timerValue / this.timerLimit;
                const barW = this.w - 10;
                ctx.fillText(this.def.label, this.x + this.w/2, this.y + 5);
                const barY = this.y + this.h - 20;
                ctx.fillStyle = 'rgba(0,0,0,0.3)';
                ctx.fillRect(this.x + 5, barY, barW, 6);
                ctx.fillStyle = 'white';
                ctx.fillRect(this.x + 5, barY, barW * pct, 6);
                ctx.font = "10px sans-serif";
                const totalSec = (this.timeSetting * this.timeBase).toFixed(1) + "s";
                ctx.fillText(totalSec, this.x + this.w/2, this.y + this.h - 12);

            } else if (this.type === 'SHIFT_REG') {
                ctx.fillText("SHIFT", this.x + this.w/2, this.y + 5);
                ctx.font = "10px sans-serif";
                ctx.fillText("8-BIT", this.x + this.w/2, this.y + 20);
            } else if (this.type === 'SEVEN_SEG') {
                this.drawSevenSeg(ctx);
            } else {
                let label = this.def.label;
                if (this.type === 'SWITCH') label = this.outputStates[0] ? 'ON' : 'OFF';
                ctx.fillText(label, this.x + this.w/2, this.y + 5);
            }
        }

        // Indicator Light for Switches
        if (['SWITCH', 'PUSH_BTN', 'CLOCK'].includes(this.type)) {
            ctx.beginPath();
            ctx.arc(this.x + this.w/2, this.y + 35, 6, 0, Math.PI*2);
            ctx.fillStyle = this.outputStates[0] ? WIRE_COLOR_ON : '#333';
            ctx.fill();
            ctx.stroke();
        }

        // Pins
        ctx.fillStyle = '#fff';
        ctx.strokeStyle = '#fff';
        
        // Inputs
        for(let i=0; i<this.inputStates.length; i++) {
            const pos = this.getInputPos(i);
            ctx.fillRect(pos.x - 5, pos.y - 5, 10, 10);
            if (isHoveringPin(pos)) {
                ctx.strokeStyle = WIRE_COLOR_ON;
                ctx.strokeRect(pos.x - 7, pos.y - 7, 14, 14);
                ctx.strokeStyle = '#fff';
            }
            
            if(this.type === 'LATCH' || this.type === 'RS_LATCH' || this.type === 'SHIFT_REG') {
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = "bold 10px monospace";
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
                let t = "";
                if(this.type.includes('LATCH')) t = (this.type==='LATCH' ? (i===0?'S':'R') : (i===0?'R':'S'));
                if(this.type==='SHIFT_REG') t = (i===0?'D': (i===1?'>':'R'));
                if(t) ctx.fillText(t, pos.x + 12, pos.y);
                ctx.fillStyle = '#fff';
            }
        }

        // Outputs
        for(let i=0; i<this.outputStates.length; i++) {
            const pos = this.getOutputPos(i);
            if (!this.isLed && this.type !== 'SEVEN_SEG') {
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 5, 0, Math.PI*2);
                ctx.fill();
                if (isHoveringPin(pos)) {
                    ctx.strokeStyle = WIRE_COLOR_ON;
                    ctx.beginPath();
                    ctx.arc(pos.x, pos.y, 8, 0, Math.PI*2);
                    ctx.stroke();
                    ctx.strokeStyle = '#fff';
                }
            }
            if (this.type === 'SHIFT_REG') {
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = "bold 10px monospace";
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";
                ctx.fillText("Q"+i, pos.x - 10, pos.y);
                ctx.fillStyle = '#fff';
            }
        }
    }

    drawSevenSeg(ctx) {
        const segW = 6;
        const segL = 35;
        const cx = this.x + 45;
        const cy = this.y + 90;
        
        const drawSeg = (id, x, y, w, h) => {
            const on = this.inputStates[id];
            ctx.fillStyle = on ? '#ff0000' : '#2a0000'; // Neon vs Dark
            if(on) { ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10; }
            roundRect(ctx, x, y, w, h, 2);
            ctx.fill();
            ctx.shadowBlur = 0;
        };

        drawSeg(0, cx - segL/2, cy - segL - segW, segL, segW); // a
        drawSeg(1, cx + segL/2, cy - segL, segW, segL); // b
        drawSeg(2, cx + segL/2, cy + segW, segW, segL); // c
        drawSeg(3, cx - segL/2, cy + segL + segW, segL, segW); // d
        drawSeg(4, cx - segL/2 - segW, cy + segW, segW, segL); // e
        drawSeg(5, cx - segL/2 - segW, cy - segL, segW, segL); // f
        drawSeg(6, cx - segL/2, cy, segL, segW); // g
        
        const on = this.inputStates[7];
        ctx.fillStyle = on ? '#ff0000' : '#2a0000';
        if(on) { ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10; }
        ctx.beginPath();
        ctx.arc(cx + segL/2 + 12, cy + segL + segW + 2, 4, 0, Math.PI*2);
        ctx.fill();
        ctx.shadowBlur = 0;
    }
}

/**
 * UTILS
 */
function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
}

function resizeCanvas() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return {
        x: clientX - rect.left,
        y: clientY - rect.top
    };
}

function getWorldPos(screenPos) {
    return { x: screenPos.x - viewX, y: screenPos.y - viewY };
}

function isHoveringPin(worldPos) {
    const mouseWorld = getWorldPos(mousePos);
    return Math.hypot(mouseWorld.x - worldPos.x, mouseWorld.y - worldPos.y) < SNAP_DIST;
}

/**
 * MAIN LOOP
 */
function updateLogic() {
    components.forEach(c => c.inputStates.fill(false));
    wires.forEach(w => {
        if (w.from.comp.outputStates[w.from.pinIdx]) {
            w.to.comp.inputStates[w.to.pinIdx] = true;
        }
    });
    components.forEach(c => c.update());
}

function gameLoop() {
    for(let i=0; i<SUB_STEPS; i++) updateLogic();
    draw();
    requestAnimationFrame(gameLoop);
}

function draw() {
    ctx.fillStyle = '#2c2c2c'; // Dark Grey
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Background Grid
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    const offsetX = viewX % GRID_SIZE;
    const offsetY = viewY % GRID_SIZE;
    for (let x = offsetX; x < canvas.width; x += GRID_SIZE) {
        for (let y = offsetY; y < canvas.height; y += GRID_SIZE) {
            ctx.fillRect(x, y, 1, 1);
        }
    }
    // Origin marker
    ctx.fillStyle = 'rgba(255,0,0,0.3)';
    ctx.fillRect(viewX-2, viewY-2, 4, 4);
    ctx.restore();

    ctx.save();
    ctx.translate(viewX, viewY);

    wires.forEach(w => {
        const start = w.from.comp.getOutputPos(w.from.pinIdx);
        const end = w.to.comp.getInputPos(w.to.pinIdx);
        drawWire(start, end, w.from.comp.outputStates[w.from.pinIdx]);
    });

    if (wiringStart) {
        let startPos, endPos, isActive;
        const mouseWorld = getWorldPos(mousePos);
        if (wiringStart.pinType === 'output') {
            startPos = wiringStart.comp.getOutputPos(wiringStart.pinIndex);
            endPos = mouseWorld;
            isActive = wiringStart.comp.outputStates[wiringStart.pinIndex];
        } else {
            startPos = mouseWorld;
            endPos = wiringStart.comp.getInputPos(wiringStart.pinIndex);
            isActive = false; 
        }
        drawWire(startPos, endPos, isActive);
    }

    components.forEach(c => c.draw(ctx));
    ctx.restore();
}

function drawWire(p1, p2, active) {
    ctx.beginPath();
    ctx.strokeStyle = active ? WIRE_COLOR_ON : WIRE_COLOR_OFF;
    ctx.lineWidth = 3;
    const cp1 = { x: p1.x + 50, y: p1.y };
    const cp2 = { x: p2.x - 50, y: p2.y };
    ctx.moveTo(p1.x, p1.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
    if (active) {
        ctx.shadowColor = WIRE_COLOR_ON;
        ctx.shadowBlur = 10;
    } else {
        ctx.shadowBlur = 0;
    }
    ctx.stroke();
    ctx.shadowBlur = 0;
}

/**
 * INTERACTION
 */
const toolItems = document.querySelectorAll('.tool-item');
toolItems.forEach(item => {
    item.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('type', item.dataset.type);
    });
});

container.addEventListener('dragover', (e) => e.preventDefault());
container.addEventListener('drop', (e) => {
    e.preventDefault();
    const type = e.dataTransfer.getData('type');
    const rect = canvas.getBoundingClientRect();
    const worldX = e.clientX - rect.left - 30 - viewX;
    const worldY = e.clientY - rect.top - 10 - viewY;
    
    // Snap to grid
    const snapX = Math.round(worldX / GRID_SIZE) * GRID_SIZE;
    const snapY = Math.round(worldY / GRID_SIZE) * GRID_SIZE;
    
    components.push(new Component(type, snapX, snapY));
});

canvas.addEventListener('mousedown', handleInputStart);
window.addEventListener('mousemove', handleInputMove);
window.addEventListener('mouseup', handleInputEnd);

canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    mousePos = getMousePos(e);
    const mouseWorld = getWorldPos(mousePos);
    
    // Wire Deletion (Right click pin)
    let pinClicked = false;
    components.forEach(c => {
        for(let i=0; i<c.inputStates.length; i++) {
            if(isHoveringPin(c.getInputPos(i))) {
                wires = wires.filter(w => !(w.to.comp === c && w.to.pinIdx === i));
                pinClicked = true;
            }
        }
        for(let i=0; i<c.outputStates.length; i++) {
             if(isHoveringPin(c.getOutputPos(i))) {
                 wires = wires.filter(w => !(w.from.comp === c && w.from.pinIdx === i));
                 pinClicked = true;
             }
        }
    });
    if (pinClicked) return;

    // Component Config / Delete
    const clickedComp = components.find(c => 
        mouseWorld.x >= c.x && mouseWorld.x <= c.x + c.w &&
        mouseWorld.y >= c.y && mouseWorld.y <= c.y + c.h
    );

    if (clickedComp) {
        const now = Date.now();
        // Double Click Check
        if (lastRightClickId === clickedComp.id && (now - lastRightClickTime < 300)) {
            wires = wires.filter(w => w.from.comp !== clickedComp && w.to.comp !== clickedComp);
            components = components.filter(c => c !== clickedComp);
            closeConfig();
            lastRightClickId = null;
            return;
        }
        lastRightClickId = clickedComp.id;
        lastRightClickTime = now;

        // Open Config
        if (clickedComp.type === 'TON' || clickedComp.type === 'TOF' || clickedComp.type === 'CLOCK' || clickedComp.def.resizable) {
            openConfig(clickedComp);
        }
    }
});

function handleInputStart(e) {
    if(e.button !== 0) return; 
    mousePos = getMousePos(e);
    const mouseWorld = getWorldPos(mousePos);
    
    // Check Pins
    for (let c of components) {
        for(let i=0; i<c.outputStates.length; i++) {
            if (isHoveringPin(c.getOutputPos(i))) {
                wiringStart = { comp: c, pinType: 'output', pinIndex: i };
                return;
            }
        }
        
        // --- CHANGE: Prevent wiring FROM LED inputs ---
        if (c.isLed) continue; 

        for(let i=0; i<c.inputStates.length; i++) {
            if (isHoveringPin(c.getInputPos(i))) {
                wiringStart = { comp: c, pinType: 'input', pinIndex: i };
                return;
            }
        }
    }

    // Check Components
    for (let i = components.length - 1; i >= 0; i--) {
        let c = components[i];
        if (mouseWorld.x >= c.x && mouseWorld.x <= c.x + c.w &&
            mouseWorld.y >= c.y && mouseWorld.y <= c.y + c.h) {
            
            if (c.type === 'PUSH_BTN') {
                c.outputStates[0] = true;
                pressedButtonId = c.id;
            }
            
            draggingComponent = c;
            dragOffset = { x: mouseWorld.x - c.x, y: mouseWorld.y - c.y };
            dragStartPos = { x: mouseWorld.x, y: mouseWorld.y };
            isDraggingComp = false; 
            components.splice(i, 1);
            components.push(c);
            return;
        }
    }

    isPanning = true;
    panStart = { x: mousePos.x - viewX, y: mousePos.y - viewY };
    container.style.cursor = "grabbing";
}

function handleInputMove(e) {
    mousePos = getMousePos(e);
    const mouseWorld = getWorldPos(mousePos);
    
    if (draggingComponent) {
        const dist = Math.hypot(mouseWorld.x - dragStartPos.x, mouseWorld.y - dragStartPos.y);
        if (dist > 5) {
            isDraggingComp = true;
            draggingComponent.x = Math.round((mouseWorld.x - dragOffset.x) / GRID_SIZE) * GRID_SIZE;
            draggingComponent.y = Math.round((mouseWorld.y - dragOffset.y) / GRID_SIZE) * GRID_SIZE;
        }
    } else if (isPanning) {
        viewX = mousePos.x - panStart.x;
        viewY = mousePos.y - panStart.y;
    }
}

function handleInputEnd(e) {
    if (pressedButtonId) {
        const btn = components.find(c => c.id === pressedButtonId);
        if (btn) btn.outputStates[0] = false;
        pressedButtonId = null;
    }

    if (draggingComponent && draggingComponent.type === 'SWITCH' && !isDraggingComp) {
        draggingComponent.outputStates[0] = !draggingComponent.outputStates[0];
    }

    if (wiringStart) {
        const mouseWorld = getWorldPos(mousePos);
        for (let c of components) {
            if (wiringStart.pinType === 'output') {
                for(let i=0; i<c.inputStates.length; i++) {
                    if (isHoveringPin(c.getInputPos(i))) {
                        wires.push({ from: { comp: wiringStart.comp, pinIdx: wiringStart.pinIndex }, to: { comp: c, pinIdx: i } });
                    }
                }
            } else {
                 for(let i=0; i<c.outputStates.length; i++) {
                    if (isHoveringPin(c.getOutputPos(i))) {
                        wires.push({ from: { comp: c, pinIdx: i }, to: { comp: wiringStart.comp, pinIdx: wiringStart.pinIndex } });
                    }
                }
            }
        }
        wiringStart = null;
    }
    
    draggingComponent = null;
    isDraggingComp = false;
    isPanning = false;
    container.style.cursor = "crosshair";
}

// --- CONFIGURATION ---
function openConfig(comp) {
    editingComponent = comp;
    const panel = document.getElementById('configPanel');
    const timerControls = document.getElementById('timerControls');
    const inputCountControls = document.getElementById('inputCountControls');
    
    timerControls.style.display = 'none';
    inputCountControls.style.display = 'none';

    if (['TON', 'TOF', 'CLOCK'].includes(comp.type)) {
        timerControls.style.display = 'block';
        document.getElementById('timerSlider').value = comp.timeSetting;
        updateValDisplay(comp.timeSetting);
        
        // Radio
        const radios = document.getElementsByName('timebase');
        for(let r of radios) { if(parseFloat(r.value) === comp.timeBase) r.checked = true; }

        // Duty
        if (comp.type === 'CLOCK') {
            document.getElementById('dutyRow').style.display = 'block';
            document.getElementById('dutySlider').value = comp.dutyCycle;
            updateDutyDisplay(comp.dutyCycle);
        } else {
            document.getElementById('dutyRow').style.display = 'none';
        }
    }
    
    if (comp.def.resizable) {
        inputCountControls.style.display = 'block';
        document.getElementById('inputCountSlider').value = comp.inputStates.length;
        updateInputCountDisplay(comp.inputStates.length);
    }

    panel.style.display = 'block';
}

function updateValDisplay(val) { document.getElementById('valDisplay').textContent = val; }
function updateDutyDisplay(val) { document.getElementById('dutyDisplay').textContent = val; }
function updateInputCountDisplay(val) { document.getElementById('inputCountDisplay').textContent = val; }

function saveConfig() {
    if (!editingComponent) return;
    
    const config = {};
    
    if (['TON', 'TOF', 'CLOCK'].includes(editingComponent.type)) {
        config.timeSetting = document.getElementById('timerSlider').value;
        config.dutyCycle = document.getElementById('dutySlider').value;
        const radios = document.getElementsByName('timebase');
        for(let r of radios) { if (r.checked) config.timeBase = r.value; }
    }
    
    if (editingComponent.def.resizable) {
        config.inputCount = document.getElementById('inputCountSlider').value;
    }
    
    editingComponent.updateConfig(config);
    closeConfig();
}

function closeConfig() {
    document.getElementById('configPanel').style.display = 'none';
    editingComponent = null;
}

// --- SAVE / LOAD ---
function saveProject() {
    // Simplify objects for JSON
    const data = {
        components: components.map(c => ({
            type: c.type,
            x: c.x,
            y: c.y,
            id: c.id,
            inputCount: c.inputStates.length, // Save configured inputs
            timerSettings: {
                timeSetting: c.timeSetting,
                timeBase: c.timeBase,
                dutyCycle: c.dutyCycle
            }
        })),
        wires: wires.map(w => ({
            fromId: w.from.comp.id,
            fromPin: w.from.pinIdx,
            toId: w.to.comp.id,
            toPin: w.to.pinIdx
        }))
    };
    
    const blob = new Blob([JSON.stringify(data)], {type: "application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = "logic_lab_circuit.json";
    a.click();
    URL.revokeObjectURL(url);
}

function loadProject(input) {
    const file = input.files[0];
    if (!file) return;
    
    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            const data = JSON.parse(e.target.result);
            clearBoard();
            
            // Recreate Components
            data.components.forEach(c => {
                const comp = new Component(c.type, c.x, c.y, c.inputCount);
                comp.id = c.id; // Restore ID for wiring
                if (c.timerSettings) comp.updateConfig(c.timerSettings);
                components.push(comp);
            });
            
            // Recreate Wires
            data.wires.forEach(w => {
                const fromComp = components.find(c => c.id === w.fromId);
                const toComp = components.find(c => c.id === w.toId);
                if (fromComp && toComp) {
                    wires.push({
                        from: { comp: fromComp, pinIdx: w.fromPin },
                        to: { comp: toComp, pinIdx: w.toPin }
                    });
                }
            });
            
        } catch (err) {
            alert("Error loading file: " + err);
        }
    };
    reader.readAsText(file);
    input.value = ''; // Reset input
}

function clearBoard() {
    if(wires.length > 0 || components.length > 0) { // Only prompt if not empty (helper for load)
       // logic mostly handled by callsite
    }
    components = [];
    wires = [];
    viewX = 0;
    viewY = 0;
}

function toggleHelp() {
    const modal = document.getElementById('helpModal');
    modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex';
}

requestAnimationFrame(gameLoop);

function loadDemo() {
    const clk = new Component('CLOCK', 100, 100);
    const sreg = new Component('SHIFT_REG', 300, 100);
    const sw = new Component('SWITCH', 100, 240);
    
    components.push(clk, sreg, sw);
    wires.push({ from: {comp: clk, pinIdx: 0}, to: {comp: sreg, pinIdx: 1} });
    wires.push({ from: {comp: sw, pinIdx: 0}, to: {comp: sreg, pinIdx: 0} }); 
}
setTimeout(loadDemo, 100);

</script>
</body>
</html>



