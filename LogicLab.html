<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Logic Lab: Circuit Simulator</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --sidebar-bg: #16213e;
            --text-color: #e94560;
            --accent: #0f3460;
            --wire-off: #53354a;
            --wire-on: #00ff9d;
            --panel-bg: #252a40;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: white;
            display: flex;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Sidebar Styling */
        #sidebar {
            width: 260px;
            background-color: var(--sidebar-bg);
            display: flex;
            flex-direction: column;
            border-right: 2px solid var(--accent);
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .logo {
            padding: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text-color);
            text-align: center;
            border-bottom: 1px solid var(--accent);
        }

        .tools-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .category-label {
            font-size: 0.8rem;
            text-transform: uppercase;
            color: #888;
            margin-top: 15px;
            margin-bottom: 5px;
            padding-left: 5px;
        }

        .tool-item {
            background-color: var(--accent);
            margin-bottom: 8px;
            padding: 10px;
            border-radius: 8px;
            cursor: grab;
            display: flex;
            align-items: center;
            transition: transform 0.1s, background 0.2s;
        }

        .tool-item:hover {
            background-color: #1a4a80;
            transform: translateX(5px);
        }

        .tool-item:active {
            cursor: grabbing;
        }

        .tool-icon {
            width: 30px;
            height: 30px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 4px;
        }

        /* Bottom Controls */
        .controls {
            padding: 15px;
            border-top: 1px solid var(--accent);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.2s;
        }

        .btn-clear {
            background-color: #e94560;
            color: white;
        }
        
        .btn-help {
            background-color: #0f3460;
            color: white;
        }
        
        .btn-save {
            background-color: var(--wire-on);
            color: #000;
        }

        .btn-cancel {
            background-color: #555;
            color: white;
        }

        button:hover {
            opacity: 0.8;
        }

        /* Canvas Area */
        #canvas-container {
            flex: 1;
            position: relative;
            background-color: #222;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }

        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }

        /* Modal styling */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: var(--sidebar-bg);
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            line-height: 1.6;
            color: #ddd;
        }
        .close-modal {
            float: right;
            cursor: pointer;
            font-size: 20px;
        }

        /* Context Menu (Config Panel) */
        #configPanel {
            display: none;
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: var(--panel-bg);
            border: 1px solid var(--accent);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 200;
            min-width: 250px;
            color: white;
        }

        #configPanel h3 {
            margin-top: 0;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            font-size: 1rem;
        }

        .config-row {
            margin-bottom: 15px;
        }

        .config-label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #aaa;
        }

        input[type="range"] {
            width: 100%;
        }

        .radio-group {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }

        .radio-label {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .radio-label input {
            margin-right: 8px;
        }
        
        .panel-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

    </style>
</head>
<body>

    <!-- Sidebar Tools -->
    <div id="sidebar">
        <div class="logo">⚡ Logic Lab</div>
        
        <div class="tools-container">
            <div class="category-label">Inputs</div>
            <div class="tool-item" draggable="true" data-type="SWITCH">
                <div class="tool-icon" style="background:#4a90e2">S</div>
                <span>Switch</span>
            </div>
            
            <div class="category-label">Outputs (LEDs)</div>
            <div class="tool-item" draggable="true" data-type="LIGHT_R">
                <div class="tool-icon" style="background:#e74c3c; color:white">R</div>
                <span>Red LED</span>
            </div>
            <div class="tool-item" draggable="true" data-type="LIGHT_G">
                <div class="tool-icon" style="background:#2ecc71; color:white">G</div>
                <span>Green LED</span>
            </div>
            <div class="tool-item" draggable="true" data-type="LIGHT_B">
                <div class="tool-icon" style="background:#3498db; color:white">B</div>
                <span>Blue LED</span>
            </div>

            <div class="category-label">Logic Gates</div>
            <div class="tool-item" draggable="true" data-type="AND">
                <div class="tool-icon" style="background:#50e3c2; color:black">&</div>
                <span>AND Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="OR">
                <div class="tool-icon" style="background:#b8e986; color:black">≥1</div>
                <span>OR Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="NOT">
                <div class="tool-icon" style="background:#bd10e0; color:white">!</div>
                <span>NOT Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="XOR">
                <div class="tool-icon" style="background:#9013fe; color:white">=1</div>
                <span>XOR Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="LATCH">
                <div class="tool-icon" style="background:#d35400; color:white">SR</div>
                <span>SR Latch</span>
            </div>
            <div class="tool-item" draggable="true" data-type="RS_LATCH">
                <div class="tool-icon" style="background:#d35400; color:white">RS</div>
                <span>RS Latch</span>
            </div>

            <div class="category-label">Timers</div>
            <div class="tool-item" draggable="true" data-type="TON">
                <div class="tool-icon" style="background:#417505; color:white">T+</div>
                <span>Timer ON (Delay)</span>
            </div>
            <div class="tool-item" draggable="true" data-type="TOF">
                <div class="tool-icon" style="background:#d0021b; color:white">T-</div>
                <span>Timer OFF (Hold)</span>
            </div>
        </div>

        <div class="controls">
            <div style="font-size: 0.8rem; color:#888; text-align:center;">
                <strong>Double Right-Click</strong> Comp to Delete.<br>
                <strong>Right-Click Pin</strong> to Delete Wires.<br>
                Drag background to Pan.<br>
                Right Click Timer to Edit.
            </div>
            <button class="btn-clear" onclick="clearBoard()">Clear Board</button>
            <button class="btn-help" onclick="toggleHelp()">How to Play</button>
        </div>
    </div>

    <!-- Main Canvas -->
    <div id="canvas-container">
        <canvas id="circuitCanvas"></canvas>
        <div id="tooltip"></div>
        
        <!-- Context Menu / Config Panel -->
        <div id="configPanel">
            <h3>Timer Settings</h3>
            <div class="config-row">
                <div class="config-label">Multiplier: <span id="valDisplay" style="color:var(--wire-on); font-weight:bold;">0.5</span></div>
                <!-- Range 0 to 1 with step 0.01 -->
                <input type="range" id="timerSlider" min="0" max="1" step="0.01" value="0.5" oninput="updateValDisplay(this.value)">
            </div>
            <div class="config-row">
                <div class="config-label">Time Base</div>
                <div class="radio-group">
                    <label class="radio-label"><input type="radio" name="timebase" value="1" checked> 1s</label>
                    <label class="radio-label"><input type="radio" name="timebase" value="10"> 10s</label>
                    <label class="radio-label"><input type="radio" name="timebase" value="100"> 100s</label>
                </div>
            </div>
            <div class="panel-actions">
                <button class="btn-cancel" onclick="closeConfig()">Cancel</button>
                <button class="btn-save" onclick="saveConfig()">Apply</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="toggleHelp()">&times;</span>
            <h2>How to Use Logic Lab</h2>
            <p>1. <strong>Add Components:</strong> Drag items from the left sidebar onto the grid.</p>
            <p>2. <strong>Pan View:</strong> Click and drag anywhere on the empty background to move the view.</p>
            <p>3. <strong>Move Items:</strong> Left-click and drag components to rearrange them.</p>
            <p>4. <strong>Wiring:</strong> Drag from a circle <strong>Output</strong> to a square <strong>Input</strong>.</p>
            <p>5. <strong>Switch:</strong> Click a switch to toggle On/Off.</p>
            <p>6. <strong>SR Latch:</strong> Set Dominant (S priority). Pin S is top, Pin R is bottom.</p>
            <p>7. <strong>RS Latch:</strong> Reset Dominant (Safety priority). Pin R is top, Pin S is bottom.</p>
        </div>
    </div>

<script>
/**
 * ENGINE CONSTANTS
 */
const GRID_SIZE = 20;
const WIRE_COLOR_OFF = '#53354a';
const WIRE_COLOR_ON = '#00ff9d';
const SNAP_DIST = 15;
const FPS = 60;

/**
 * STATE MANAGEMENT
 */
const canvas = document.getElementById('circuitCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');

// View State (Panning)
let viewX = 0;
let viewY = 0;
let isPanning = false;
let panStart = { x: 0, y: 0 };

let components = [];
let wires = []; 

let draggingComponent = null;
let dragOffset = { x: 0, y: 0 };
let isDraggingComp = false; 
let dragStartPos = {x:0, y:0};

let wiringStart = null; 
let mousePos = { x: 0, y: 0 }; // Always screen coordinates relative to canvas

// Config Panel State
let editingComponent = null;

// Double Right Click Logic
let lastRightClickTime = 0;
let lastRightClickId = null;

/**
 * COMPONENT DEFINITIONS
 */
const COMP_TYPES = {
    SWITCH:   { w: 60, h: 60, inputs: 0, outputs: 1, color: '#4a90e2', label: 'SW' },
    LIGHT_R:  { w: 60, h: 60, inputs: 1, outputs: 0, color: '#333333', onColor: '#e74c3c', label: 'RED' },
    LIGHT_G:  { w: 60, h: 60, inputs: 1, outputs: 0, color: '#333333', onColor: '#2ecc71', label: 'GRN' },
    LIGHT_B:  { w: 60, h: 60, inputs: 1, outputs: 0, color: '#333333', onColor: '#3498db', label: 'BLU' },
    AND:      { w: 80, h: 60, inputs: 2, outputs: 1, color: '#50e3c2', label: '&', textColor: 'black' },
    OR:       { w: 80, h: 60, inputs: 2, outputs: 1, color: '#b8e986', label: '≥1', textColor: 'black' },
    NOT:      { w: 60, h: 40, inputs: 1, outputs: 1, color: '#bd10e0', label: '1', shape: 'triangle' },
    XOR:      { w: 80, h: 60, inputs: 2, outputs: 1, color: '#9013fe', label: '=1' },
    LATCH:    { w: 80, h: 60, inputs: 2, outputs: 1, color: '#d35400', label: 'SR' }, // Set Dominant
    RS_LATCH: { w: 80, h: 60, inputs: 2, outputs: 1, color: '#d35400', label: 'RS' }, // Reset Dominant
    TON:      { w: 80, h: 60, inputs: 1, outputs: 1, color: '#417505', label: 'TON' }, 
    TOF:      { w: 80, h: 60, inputs: 1, outputs: 1, color: '#d0021b', label: 'TOF' }, 
};

class Component {
    constructor(type, x, y) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.type = type;
        this.def = COMP_TYPES[type];
        this.x = x;
        this.y = y;
        this.w = this.def.w;
        this.h = this.def.h;
        
        // State
        this.state = false; 
        this.inputStates = new Array(this.def.inputs).fill(false);
        
        // Timer specifics
        this.timerValue = 0; // Current count (in frames)
        this.timeSetting = 0.5; // Default slider value
        this.timeBase = 1.0; // Default base
        this.updateTimerLimit();
    }

    updateConfig(val, base) {
        this.timeSetting = parseFloat(val);
        this.timeBase = parseFloat(base);
        this.updateTimerLimit();
        // Reset if invalid state
        if (this.timerValue > this.timerLimit) this.timerValue = this.timerLimit;
    }

    updateTimerLimit() {
        // limit = setting * base * 60fps
        this.timerLimit = Math.max(1, Math.round(this.timeSetting * this.timeBase * FPS));
    }

    // Logic Update Tick
    update() {
        if (this.type === 'AND') {
            this.state = this.inputStates[0] && this.inputStates[1];
        } else if (this.type === 'OR') {
            this.state = this.inputStates[0] || this.inputStates[1];
        } else if (this.type === 'NOT') {
            this.state = !this.inputStates[0];
        } else if (this.type === 'XOR') {
            this.state = (this.inputStates[0] ? 1 : 0) ^ (this.inputStates[1] ? 1 : 0);
        } else if (this.type === 'LATCH') {
            // SR Latch (Set Dominant - Standard PLC SR)
            // Input 0: Set (Top)
            // Input 1: Reset (Bottom)
            const set = this.inputStates[0];
            const rst = this.inputStates[1];
            
            if (set) {
                this.state = true;
            } else if (rst) {
                this.state = false;
            }
            // If both, Set ran first in logic block? No, if (set) triggers, else if (rst) is skipped.
            // Thus, Set is dominant.
        } else if (this.type === 'RS_LATCH') {
            // RS Latch (Reset Dominant - Standard PLC RS)
            // Input 0: Reset (Top) -- Convention for RS
            // Input 1: Set (Bottom)
            const rst = this.inputStates[0];
            const set = this.inputStates[1];
            
            if (rst) {
                this.state = false;
            } else if (set) {
                this.state = true;
            }
            // If both, Reset triggers first. Reset is dominant.
        } else if (this.type.startsWith('LIGHT')) {
            this.state = this.inputStates[0];
        } else if (this.type === 'TON') {
            if (this.inputStates[0]) {
                if (this.timerValue < this.timerLimit) this.timerValue++;
            } else {
                this.timerValue = 0;
            }
            this.state = (this.timerValue >= this.timerLimit);
        } else if (this.type === 'TOF') {
            if (this.inputStates[0]) {
                this.state = true;
                this.timerValue = this.timerLimit;
            } else {
                if (this.timerValue > 0) {
                    this.timerValue--;
                    this.state = true;
                } else {
                    this.state = false;
                }
            }
        }
    }

    getInputPos(index) {
        const spacing = this.h / (this.def.inputs + 1);
        return { x: this.x, y: this.y + spacing * (index + 1) };
    }

    getOutputPos(index) {
        return { x: this.x + this.w, y: this.y + this.h / 2 };
    }

    draw(ctx) {
        let fillColor = this.def.color;
        if (this.type.startsWith('LIGHT') && this.state) {
            fillColor = this.def.onColor;
        }
        ctx.fillStyle = fillColor;
        
        if (this === draggingComponent) {
            ctx.shadowColor = 'rgba(255,255,255,0.5)';
            ctx.shadowBlur = 10;
        }

        ctx.beginPath();
        if (this.type === 'NOT') {
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + this.w, this.y + this.h/2);
            ctx.lineTo(this.x, this.y + this.h);
            ctx.closePath();
            ctx.fill();
        } else {
            roundRect(ctx, this.x, this.y, this.w, this.h, 6);
            ctx.fill();
        }
        ctx.shadowBlur = 0;

        ctx.fillStyle = this.def.textColor || 'white';
        ctx.font = "bold 16px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        if ((this.type === 'TON' || this.type === 'TOF')) {
            let pct = this.timerValue / this.timerLimit;
            const barW = this.w - 20;
            const barX = this.x + 10;
            const barY = this.y + 40;
            
            ctx.fillText(this.def.label, this.x + this.w/2, this.y + 20);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(barX, barY, barW, 6);
            ctx.fillStyle = 'white';
            ctx.fillRect(barX, barY, barW * pct, 6);

            ctx.font = "10px sans-serif";
            const totalSec = (this.timeSetting * this.timeBase).toFixed(2) + "s";
            ctx.fillText(totalSec, this.x + this.w/2, this.y + 55);
        } else {
            let label = this.def.label;
            if (this.type === 'SWITCH') label = this.state ? 'ON' : 'OFF';
            ctx.fillText(label, this.x + this.w/2, this.y + this.h/2);
        }

        if (this.type === 'SWITCH' || this.type.startsWith('LIGHT') || this.type === 'LATCH' || this.type === 'RS_LATCH') {
            ctx.beginPath();
            ctx.arc(this.x + this.w/2, this.y - 10, 6, 0, Math.PI*2);
            if (this.type.startsWith('LIGHT')) {
                ctx.fillStyle = this.state ? this.def.onColor : '#222';
            } else {
                ctx.fillStyle = this.state ? WIRE_COLOR_ON : '#333';
            }
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.stroke();
        }

        ctx.fillStyle = '#fff';
        for(let i=0; i<this.def.inputs; i++) {
            const pos = this.getInputPos(i);
            ctx.fillRect(pos.x - 5, pos.y - 5, 10, 10);
            // Pass world coordinates to hovering check
            if (isHoveringPin(pos)) {
                ctx.strokeStyle = WIRE_COLOR_ON;
                ctx.strokeRect(pos.x - 7, pos.y - 7, 14, 14);
            }
            
            if (this.type === 'LATCH' || this.type === 'RS_LATCH') {
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = "bold 10px monospace";
                ctx.textAlign = "left";
                ctx.textBaseline = "middle";
                
                let label = "";
                if (this.type === 'LATCH') {
                    // SR: Top S, Bottom R
                    label = (i === 0) ? "S" : "R";
                } else {
                    // RS: Top R, Bottom S
                    label = (i === 0) ? "R" : "S";
                }
                
                ctx.fillText(label, pos.x + 10, pos.y);
                ctx.fillStyle = '#fff';
            }
        }

        for(let i=0; i<this.def.outputs; i++) {
            const pos = this.getOutputPos(i);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 5, 0, Math.PI*2);
            ctx.fill();
            if (isHoveringPin(pos)) {
                ctx.strokeStyle = WIRE_COLOR_ON;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 8, 0, Math.PI*2);
                ctx.stroke();
            }
        }
    }
}

/**
 * UTILS
 */
function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
}

function resizeCanvas() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return {
        x: clientX - rect.left,
        y: clientY - rect.top
    };
}

// Transform Screen Coordinates to World Coordinates
function getWorldPos(screenPos) {
    return {
        x: screenPos.x - viewX,
        y: screenPos.y - viewY
    };
}

// Check hovering using World Coordinates
function isHoveringPin(worldPos) {
    const mouseWorld = getWorldPos(mousePos);
    const d = Math.hypot(mouseWorld.x - worldPos.x, mouseWorld.y - worldPos.y);
    return d < SNAP_DIST;
}

/**
 * MAIN LOOP
 */
function gameLoop() {
    // Logic Tick
    components.forEach(c => {
        for(let i=0; i<c.def.inputs; i++) c.inputStates[i] = false;
    });

    wires.forEach(w => {
        if (w.from.comp.state) {
            w.to.comp.inputStates[w.to.pinIdx] = true;
        }
    });

    components.forEach(c => c.update());

    draw();
    requestAnimationFrame(gameLoop);
}

function draw() {
    ctx.fillStyle = '#1a1a2e';
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // BACKGROUND GRID (Fixed Pattern that pans)
    ctx.save();
    
    // Draw grid pattern based on offset
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    
    // Calculate start offset for grid lines so they appear infinite
    const offsetX = viewX % GRID_SIZE;
    const offsetY = viewY % GRID_SIZE;
    
    for (let x = offsetX; x < canvas.width; x += GRID_SIZE) {
        for (let y = offsetY; y < canvas.height; y += GRID_SIZE) {
            ctx.fillRect(x, y, 1, 1);
        }
    }
    
    // Center point marker (Origin)
    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
    ctx.fillRect(viewX - 2, viewY - 2, 4, 4);
    
    ctx.restore();

    // WORLD CONTENT
    ctx.save();
    ctx.translate(viewX, viewY);

    // Wires
    wires.forEach(w => {
        const start = w.from.comp.getOutputPos(w.from.pinIdx);
        const end = w.to.comp.getInputPos(w.to.pinIdx);
        drawWire(start, end, w.from.comp.state);
    });

    // Temp Wire
    if (wiringStart) {
        let startPos, endPos, isActive;
        const mouseWorld = getWorldPos(mousePos);
        
        if (wiringStart.pinType === 'output') {
            startPos = wiringStart.comp.getOutputPos(wiringStart.pinIndex);
            endPos = mouseWorld;
            isActive = wiringStart.comp.state;
        } else {
            startPos = mouseWorld;
            endPos = wiringStart.comp.getInputPos(wiringStart.pinIndex);
            isActive = false; 
        }
        drawWire(startPos, endPos, isActive);
    }

    components.forEach(c => c.draw(ctx));
    
    ctx.restore();
}

function drawWire(p1, p2, active) {
    ctx.beginPath();
    ctx.strokeStyle = active ? WIRE_COLOR_ON : WIRE_COLOR_OFF;
    ctx.lineWidth = 3;
    const cp1 = { x: p1.x + 50, y: p1.y };
    const cp2 = { x: p2.x - 50, y: p2.y };
    ctx.moveTo(p1.x, p1.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
    
    if (active) {
        ctx.shadowColor = WIRE_COLOR_ON;
        ctx.shadowBlur = 10;
    } else {
        ctx.shadowBlur = 0;
    }
    ctx.stroke();
    ctx.shadowBlur = 0;
}

/**
 * INTERACTION
 */
const toolItems = document.querySelectorAll('.tool-item');
toolItems.forEach(item => {
    item.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('type', item.dataset.type);
    });
});

container.addEventListener('dragover', (e) => e.preventDefault());
container.addEventListener('drop', (e) => {
    e.preventDefault();
    const type = e.dataTransfer.getData('type');
    const rect = canvas.getBoundingClientRect();
    
    // Calculate Drop Position in World Coordinates
    const screenX = e.clientX - rect.left - 30;
    const screenY = e.clientY - rect.top - 30;
    const worldX = screenX - viewX;
    const worldY = screenY - viewY;
    
    const snapX = Math.round(worldX / GRID_SIZE) * GRID_SIZE;
    const snapY = Math.round(worldY / GRID_SIZE) * GRID_SIZE;
    components.push(new Component(type, snapX, snapY));
});

canvas.addEventListener('mousedown', handleInputStart);
window.addEventListener('mousemove', handleInputMove);
window.addEventListener('mouseup', handleInputEnd);

// Context Menu (Right Click)
canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    mousePos = getMousePos(e);
    const mouseWorld = getWorldPos(mousePos);
    
    // 1. Check for Pins (Wire Delete) - Single Right Click
    let pinClicked = false;
    components.forEach(c => {
        // Check Inputs
        for(let i=0; i<c.def.inputs; i++) {
            const pos = c.getInputPos(i);
            const d = Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y);
            if(d < SNAP_DIST) {
                wires = wires.filter(w => !(w.to.comp === c && w.to.pinIdx === i));
                pinClicked = true;
            }
        }
        // Check Outputs
        for(let i=0; i<c.def.outputs; i++) {
             const pos = c.getOutputPos(i);
             const d = Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y);
             if(d < SNAP_DIST) {
                 // Remove all wires originating from this output
                 wires = wires.filter(w => !(w.from.comp === c && w.from.pinIdx === i));
                 pinClicked = true;
             }
        }
    });
    if (pinClicked) return;

    // 2. Check for Component Hit
    const clickedComp = components.find(c => 
        mouseWorld.x >= c.x && mouseWorld.x <= c.x + c.w &&
        mouseWorld.y >= c.y && mouseWorld.y <= c.y + c.h
    );

    if (clickedComp) {
        // Double Right Click Detection
        const now = Date.now();
        if (lastRightClickId === clickedComp.id && (now - lastRightClickTime < 300)) {
            // Double Right Click -> Delete Component
            wires = wires.filter(w => w.from.comp !== clickedComp && w.to.comp !== clickedComp);
            components = components.filter(c => c !== clickedComp);
            closeConfig();
            lastRightClickId = null;
            return;
        }
        
        // Register first click
        lastRightClickId = clickedComp.id;
        lastRightClickTime = now;

        // Single Right Click -> Open Config if Timer
        if (clickedComp.type === 'TON' || clickedComp.type === 'TOF') {
            openConfig(clickedComp);
        }
    }
});

function handleInputStart(e) {
    if(e.button !== 0) return; // Only Left Click
    mousePos = getMousePos(e);
    const mouseWorld = getWorldPos(mousePos);
    
    // 1. Check Pins (Wiring)
    for (let c of components) {
        for(let i=0; i<c.def.outputs; i++) {
            const pos = c.getOutputPos(i);
            if (Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y) < SNAP_DIST) {
                wiringStart = { comp: c, pinType: 'output', pinIndex: i };
                return;
            }
        }
        for(let i=0; i<c.def.inputs; i++) {
            const pos = c.getInputPos(i);
            if (Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y) < SNAP_DIST) {
                wiringStart = { comp: c, pinType: 'input', pinIndex: i };
                return;
            }
        }
    }

    // 2. Check Components (Drag/Toggle)
    for (let i = components.length - 1; i >= 0; i--) {
        let c = components[i];
        if (mouseWorld.x >= c.x && mouseWorld.x <= c.x + c.w &&
            mouseWorld.y >= c.y && mouseWorld.y <= c.y + c.h) {
            
            draggingComponent = c;
            dragOffset = { x: mouseWorld.x - c.x, y: mouseWorld.y - c.y };
            dragStartPos = { x: mouseWorld.x, y: mouseWorld.y };
            isDraggingComp = false; 
            
            // Move to top
            components.splice(i, 1);
            components.push(c);
            return;
        }
    }

    // 3. Background (Pan)
    isPanning = true;
    panStart = { x: mousePos.x - viewX, y: mousePos.y - viewY };
    container.style.cursor = "grabbing";
}

function handleInputMove(e) {
    mousePos = getMousePos(e);
    const mouseWorld = getWorldPos(mousePos);
    
    if (draggingComponent) {
        const dist = Math.hypot(mouseWorld.x - dragStartPos.x, mouseWorld.y - dragStartPos.y);
        if (dist > 5) {
            isDraggingComp = true;
            draggingComponent.x = Math.round((mouseWorld.x - dragOffset.x) / GRID_SIZE) * GRID_SIZE;
            draggingComponent.y = Math.round((mouseWorld.y - dragOffset.y) / GRID_SIZE) * GRID_SIZE;
        }
    } else if (isPanning) {
        viewX = mousePos.x - panStart.x;
        viewY = mousePos.y - panStart.y;
    }
}

function handleInputEnd(e) {
    if (draggingComponent && draggingComponent.type === 'SWITCH' && !isDraggingComp) {
        draggingComponent.state = !draggingComponent.state;
    }

    if (wiringStart) {
        const mouseWorld = getWorldPos(mousePos);
        for (let c of components) {
            if (wiringStart.pinType === 'output') {
                for(let i=0; i<c.def.inputs; i++) {
                    const pos = c.getInputPos(i);
                    if (Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y) < SNAP_DIST) {
                        if (c === wiringStart.comp) continue;
                        wires = wires.filter(w => !(w.to.comp === c && w.to.pinIdx === i));
                        wires.push({ from: { comp: wiringStart.comp, pinIdx: wiringStart.pinIndex }, to: { comp: c, pinIdx: i } });
                    }
                }
            } else {
                 for(let i=0; i<c.def.outputs; i++) {
                    const pos = c.getOutputPos(i);
                    if (Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y) < SNAP_DIST) {
                        if (c === wiringStart.comp) continue;
                        wires = wires.filter(w => !(w.to.comp === wiringStart.comp && w.to.pinIdx === wiringStart.pinIndex));
                        wires.push({ from: { comp: c, pinIdx: i }, to: { comp: wiringStart.comp, pinIdx: wiringStart.pinIndex } });
                    }
                }
            }
        }
        wiringStart = null;
    }
    
    draggingComponent = null;
    isDraggingComp = false;
    isPanning = false;
    container.style.cursor = "crosshair";
}

// CONFIG UI LOGIC
function openConfig(comp) {
    editingComponent = comp;
    const panel = document.getElementById('configPanel');
    const slider = document.getElementById('timerSlider');
    const valDisplay = document.getElementById('valDisplay');
    
    // Set Values
    slider.value = comp.timeSetting;
    valDisplay.textContent = comp.timeSetting;
    
    // Set Radio
    const radios = document.getElementsByName('timebase');
    for(let r of radios) {
        if(parseFloat(r.value) === comp.timeBase) r.checked = true;
    }

    panel.style.display = 'block';
}

function updateValDisplay(val) {
    document.getElementById('valDisplay').textContent = val;
}

function saveConfig() {
    if (!editingComponent) return;
    const sliderVal = document.getElementById('timerSlider').value;
    const radios = document.getElementsByName('timebase');
    let baseVal = 1;
    for(let r of radios) {
        if (r.checked) baseVal = r.value;
    }
    
    editingComponent.updateConfig(sliderVal, baseVal);
    closeConfig();
}

function closeConfig() {
    document.getElementById('configPanel').style.display = 'none';
    editingComponent = null;
}

function clearBoard() {
    if(confirm("Clear all components?")) {
        components = [];
        wires = [];
        viewX = 0;
        viewY = 0;
    }
}

function toggleHelp() {
    const modal = document.getElementById('helpModal');
    modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex';
}

requestAnimationFrame(gameLoop);

function loadDemo() {
    // Demo content should appear near origin
    const sw1 = new Component('SWITCH', 100, 100);
    const ton = new Component('TON', 300, 100);
    const light = new Component('LIGHT_G', 500, 100);
    
    components.push(sw1, ton, light);
    
    wires.push({ from: {comp: sw1, pinIdx: 0}, to: {comp: ton, pinIdx: 0} });
    wires.push({ from: {comp: ton, pinIdx: 0}, to: {comp: light, pinIdx: 0} });
}
setTimeout(loadDemo, 100);

</script>
</body>
</html>


