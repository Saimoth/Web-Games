<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Logic Lab: Circuit Simulator</title>
    <style>
        :root {
            --bg-color: #1a1a2e;
            --sidebar-bg: #16213e;
            --text-color: #e94560;
            --accent: #0f3460;
            --wire-off: #53354a;
            --wire-on: #00ff9d;
            --panel-bg: #252a40;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: white;
            display: flex;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }

        /* Sidebar Styling */
        #sidebar {
            width: 260px;
            background-color: var(--sidebar-bg);
            display: flex;
            flex-direction: column;
            border-right: 2px solid var(--accent);
            box-shadow: 2px 0 10px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .logo {
            padding: 20px;
            font-size: 1.5rem;
            font-weight: bold;
            color: var(--text-color);
            text-align: center;
            border-bottom: 1px solid var(--accent);
        }

        .tools-container {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
        }

        .category-label {
            font-size: 0.8rem;
            text-transform: uppercase;
            color: #888;
            margin-top: 15px;
            margin-bottom: 5px;
            padding-left: 5px;
        }

        .tool-item {
            background-color: var(--accent);
            margin-bottom: 8px;
            padding: 10px;
            border-radius: 8px;
            cursor: grab;
            display: flex;
            align-items: center;
            transition: transform 0.1s, background 0.2s;
        }

        .tool-item:hover {
            background-color: #1a4a80;
            transform: translateX(5px);
        }

        .tool-item:active {
            cursor: grabbing;
        }

        .tool-icon {
            width: 30px;
            height: 30px;
            margin-right: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            border-radius: 4px;
        }

        /* Bottom Controls */
        .controls {
            padding: 15px;
            border-top: 1px solid var(--accent);
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        button {
            padding: 10px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            transition: opacity 0.2s;
        }

        .btn-clear {
            background-color: #e94560;
            color: white;
        }
        
        .btn-help {
            background-color: #0f3460;
            color: white;
        }
        
        .btn-save {
            background-color: var(--wire-on);
            color: #000;
        }

        .btn-cancel {
            background-color: #555;
            color: white;
        }

        button:hover {
            opacity: 0.8;
        }

        /* Canvas Area */
        #canvas-container {
            flex: 1;
            position: relative;
            background-color: #222;
            overflow: hidden;
            cursor: crosshair;
        }

        canvas {
            display: block;
        }

        #tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 100;
        }

        /* Modal styling */
        .modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }
        .modal-content {
            background: var(--sidebar-bg);
            padding: 30px;
            border-radius: 10px;
            max-width: 500px;
            line-height: 1.6;
            color: #ddd;
        }
        .close-modal {
            float: right;
            cursor: pointer;
            font-size: 20px;
        }

        /* Context Menu (Config Panel) */
        #configPanel {
            display: none;
            position: absolute;
            bottom: 20px;
            right: 20px;
            background-color: var(--panel-bg);
            border: 1px solid var(--accent);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            z-index: 200;
            min-width: 250px;
            color: white;
        }

        #configPanel h3 {
            margin-top: 0;
            border-bottom: 1px solid #444;
            padding-bottom: 10px;
            font-size: 1rem;
        }

        .config-row {
            margin-bottom: 15px;
        }

        .config-label {
            display: block;
            margin-bottom: 5px;
            font-size: 0.9rem;
            color: #aaa;
        }

        input[type="range"] {
            width: 100%;
        }

        .radio-group {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 8px;
        }

        .radio-label {
            display: flex;
            align-items: center;
            font-size: 0.9rem;
            cursor: pointer;
        }

        .radio-label input {
            margin-right: 8px;
        }
        
        .panel-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 20px;
        }

    </style>
</head>
<body>

    <!-- Sidebar Tools -->
    <div id="sidebar">
        <div class="logo">⚡ Logic Lab</div>
        
        <div class="tools-container">
            <div class="category-label">Inputs</div>
            <div class="tool-item" draggable="true" data-type="SWITCH">
                <div class="tool-icon" style="background:#4a90e2">SW</div>
                <span>Toggle Switch</span>
            </div>
            <div class="tool-item" draggable="true" data-type="PUSH_BTN">
                <div class="tool-icon" style="background:#2ecc71; color:black">PB</div>
                <span>Push Button</span>
            </div>
            <div class="tool-item" draggable="true" data-type="CLOCK">
                <div class="tool-icon" style="background:#34495e; color:white">Clk</div>
                <span>Clock Gen</span>
            </div>
            
            <div class="category-label">Outputs (LEDs)</div>
            <div class="tool-item" draggable="true" data-type="LIGHT_R">
                <div class="tool-icon" style="background:#e74c3c; color:white">R</div>
                <span>Red LED</span>
            </div>
            <div class="tool-item" draggable="true" data-type="LIGHT_G">
                <div class="tool-icon" style="background:#2ecc71; color:white">G</div>
                <span>Green LED</span>
            </div>
            <div class="tool-item" draggable="true" data-type="LIGHT_B">
                <div class="tool-icon" style="background:#3498db; color:white">B</div>
                <span>Blue LED</span>
            </div>
            <div class="tool-item" draggable="true" data-type="SEVEN_SEG">
                <div class="tool-icon" style="background:#222; color:red; border:1px solid #444;">8.</div>
                <span>7-Seg Display</span>
            </div>

            <div class="category-label">Logic Gates</div>
            <div class="tool-item" draggable="true" data-type="AND">
                <div class="tool-icon" style="background:#50e3c2; color:black">&</div>
                <span>AND Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="OR">
                <div class="tool-icon" style="background:#b8e986; color:black">≥1</div>
                <span>OR Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="NOT">
                <div class="tool-icon" style="background:#bd10e0; color:white">!</div>
                <span>NOT Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="XOR">
                <div class="tool-icon" style="background:#9013fe; color:white">=1</div>
                <span>XOR Gate</span>
            </div>
            <div class="tool-item" draggable="true" data-type="LATCH">
                <div class="tool-icon" style="background:#d35400; color:white">SR</div>
                <span>SR Latch</span>
            </div>
            <div class="tool-item" draggable="true" data-type="RS_LATCH">
                <div class="tool-icon" style="background:#d35400; color:white">RS</div>
                <span>RS Latch</span>
            </div>

            <div class="category-label">Complex</div>
            <div class="tool-item" draggable="true" data-type="SHIFT_REG">
                <div class="tool-icon" style="background:#8e44ad; color:white">SR</div>
                <span>Shift Reg (8)</span>
            </div>
            <div class="tool-item" draggable="true" data-type="TON">
                <div class="tool-icon" style="background:#417505; color:white">T+</div>
                <span>Timer ON (Delay)</span>
            </div>
            <div class="tool-item" draggable="true" data-type="TOF">
                <div class="tool-icon" style="background:#d0021b; color:white">T-</div>
                <span>Timer OFF (Hold)</span>
            </div>
        </div>

        <div class="controls">
            <div style="font-size: 0.8rem; color:#888; text-align:center;">
                <strong>Double Right-Click</strong> Comp to Delete.<br>
                <strong>Right-Click Pin</strong> to Delete Wires.<br>
                Drag background to Pan.<br>
                Right Click Timer/Clock to Edit.
            </div>
            <button class="btn-clear" onclick="clearBoard()">Clear Board</button>
            <button class="btn-help" onclick="toggleHelp()">How to Play</button>
        </div>
    </div>

    <!-- Main Canvas -->
    <div id="canvas-container">
        <canvas id="circuitCanvas"></canvas>
        <div id="tooltip"></div>
        
        <!-- Context Menu / Config Panel -->
        <div id="configPanel">
            <h3 id="configTitle">Settings</h3>
            <div class="config-row">
                <div class="config-label">Period/Duration: <span id="valDisplay" style="color:var(--wire-on); font-weight:bold;">0.5</span></div>
                <input type="range" id="timerSlider" min="0" max="1" step="0.01" value="0.5" oninput="updateValDisplay(this.value)">
            </div>
            
            <div class="config-row" id="dutyRow" style="display:none;">
                <div class="config-label">Duty Cycle %: <span id="dutyDisplay" style="color:var(--wire-on); font-weight:bold;">50</span></div>
                <input type="range" id="dutySlider" min="0" max="100" step="5" value="50" oninput="updateDutyDisplay(this.value)">
            </div>

            <div class="config-row">
                <div class="config-label">Time Base</div>
                <div class="radio-group">
                    <label class="radio-label"><input type="radio" name="timebase" value="1" checked> 1s</label>
                    <label class="radio-label"><input type="radio" name="timebase" value="10"> 10s</label>
                    <label class="radio-label"><input type="radio" name="timebase" value="100"> 100s</label>
                </div>
            </div>
            <div class="panel-actions">
                <button class="btn-cancel" onclick="closeConfig()">Cancel</button>
                <button class="btn-save" onclick="saveConfig()">Apply</button>
            </div>
        </div>
    </div>

    <!-- Help Modal -->
    <div id="helpModal" class="modal">
        <div class="modal-content">
            <span class="close-modal" onclick="toggleHelp()">&times;</span>
            <h2>How to Use Logic Lab</h2>
            <p>1. <strong>Push Button:</strong> Active only while held down.</p>
            <p>2. <strong>Clock Gen:</strong> Generates square wave. Right-click to set Frequency and Duty Cycle.</p>
            <p>3. <strong>Shift Register:</strong> 8-bit Serial-In Parallel-Out. Top In: Data, Mid In: Clock, Bot In: Reset.</p>
            <p>4. <strong>7-Seg Display:</strong> 8 Inputs. Top to Bottom: a, b, c, d, e, f, g, dp.</p>
            <p>5. <strong>Wiring:</strong> Drag from Circle (Out) to Square (In).</p>
            <p>6. <strong>Controls:</strong>
                <br>- Double Right-Click Component: Delete
                <br>- Right-Click Pin: Clear Wires
                <br>- Drag Background: Pan View
            </p>
        </div>
    </div>

<script>
/**
 * ENGINE CONSTANTS
 */
const GRID_SIZE = 20;
const WIRE_COLOR_OFF = '#53354a';
const WIRE_COLOR_ON = '#00ff9d';
const SNAP_DIST = 15;
const FPS = 60;

/**
 * STATE MANAGEMENT
 */
const canvas = document.getElementById('circuitCanvas');
const ctx = canvas.getContext('2d');
const container = document.getElementById('canvas-container');

// View State (Panning)
let viewX = 0;
let viewY = 0;
let isPanning = false;
let panStart = { x: 0, y: 0 };

let components = [];
let wires = []; 

let draggingComponent = null;
let dragOffset = { x: 0, y: 0 };
let isDraggingComp = false; 
let dragStartPos = {x:0, y:0};
let pressedButtonId = null; // Track held push buttons

let wiringStart = null; 
let mousePos = { x: 0, y: 0 };

// Config Panel State
let editingComponent = null;

// Double Right Click Logic
let lastRightClickTime = 0;
let lastRightClickId = null;

/**
 * COMPONENT DEFINITIONS
 */
const COMP_TYPES = {
    SWITCH:    { w: 60, h: 60, inputs: 0, outputs: 1, color: '#4a90e2', label: 'SW' },
    PUSH_BTN:  { w: 60, h: 60, inputs: 0, outputs: 1, color: '#27ae60', label: 'PB' },
    CLOCK:     { w: 60, h: 60, inputs: 0, outputs: 1, color: '#34495e', label: 'CLK' },
    
    LIGHT_R:   { w: 60, h: 60, inputs: 1, outputs: 0, color: '#333333', onColor: '#e74c3c', label: 'RED' },
    LIGHT_G:   { w: 60, h: 60, inputs: 1, outputs: 0, color: '#333333', onColor: '#2ecc71', label: 'GRN' },
    LIGHT_B:   { w: 60, h: 60, inputs: 1, outputs: 0, color: '#333333', onColor: '#3498db', label: 'BLU' },
    
    SEVEN_SEG: { w: 90, h: 160, inputs: 8, outputs: 0, color: '#222', label: '' },
    
    AND:       { w: 80, h: 60, inputs: 2, outputs: 1, color: '#50e3c2', label: '&', textColor: 'black' },
    OR:        { w: 80, h: 60, inputs: 2, outputs: 1, color: '#b8e986', label: '≥1', textColor: 'black' },
    NOT:       { w: 60, h: 40, inputs: 1, outputs: 1, color: '#bd10e0', label: '1', shape: 'triangle' },
    XOR:       { w: 80, h: 60, inputs: 2, outputs: 1, color: '#9013fe', label: '=1' },
    
    LATCH:     { w: 80, h: 60, inputs: 2, outputs: 1, color: '#d35400', label: 'SR' }, 
    RS_LATCH:  { w: 80, h: 60, inputs: 2, outputs: 1, color: '#d35400', label: 'RS' }, 
    
    SHIFT_REG: { w: 100, h: 180, inputs: 3, outputs: 8, color: '#8e44ad', label: 'SHIFT' },
    
    TON:       { w: 80, h: 60, inputs: 1, outputs: 1, color: '#417505', label: 'TON' }, 
    TOF:       { w: 80, h: 60, inputs: 1, outputs: 1, color: '#d0021b', label: 'TOF' }, 
};

class Component {
    constructor(type, x, y) {
        this.id = Math.random().toString(36).substr(2, 9);
        this.type = type;
        this.def = COMP_TYPES[type];
        this.x = x;
        this.y = y;
        this.w = this.def.w;
        this.h = this.def.h;
        
        // State Management
        this.outputStates = new Array(this.def.outputs).fill(false);
        this.inputStates = new Array(this.def.inputs).fill(false);
        
        // Timer/Clock specifics
        this.timerValue = 0; 
        this.timeSetting = 0.5; 
        this.timeBase = 1.0; 
        this.dutyCycle = 50; 
        this.updateTimerLimit();
        
        // Shift Register Specifics
        this.prevClockState = false;
    }

    updateConfig(val, base, duty) {
        this.timeSetting = parseFloat(val);
        this.timeBase = parseFloat(base);
        if(duty !== undefined) this.dutyCycle = parseInt(duty);
        this.updateTimerLimit();
    }

    updateTimerLimit() {
        this.timerLimit = Math.max(1, Math.round(this.timeSetting * this.timeBase * FPS));
    }

    update() {
        if (this.type === 'AND') this.outputStates[0] = this.inputStates[0] && this.inputStates[1];
        else if (this.type === 'OR') this.outputStates[0] = this.inputStates[0] || this.inputStates[1];
        else if (this.type === 'NOT') this.outputStates[0] = !this.inputStates[0];
        else if (this.type === 'XOR') this.outputStates[0] = (this.inputStates[0] ? 1 : 0) ^ (this.inputStates[1] ? 1 : 0);
        
        else if (this.type === 'LATCH') { // SR Set Dominant
            const set = this.inputStates[0];
            const rst = this.inputStates[1];
            if (set) this.outputStates[0] = true;
            else if (rst) this.outputStates[0] = false;
        } else if (this.type === 'RS_LATCH') { // RS Reset Dominant
            const rst = this.inputStates[0];
            const set = this.inputStates[1];
            if (rst) this.outputStates[0] = false;
            else if (set) this.outputStates[0] = true;
        } 
        
        else if (this.type.startsWith('LIGHT')) {
            this.outputStates[0] = this.inputStates[0];
        } 
        
        else if (this.type === 'TON') {
            if (this.inputStates[0]) {
                if (this.timerValue < this.timerLimit) this.timerValue++;
            } else {
                this.timerValue = 0;
            }
            this.outputStates[0] = (this.timerValue >= this.timerLimit);
        } else if (this.type === 'TOF') {
            if (this.inputStates[0]) {
                this.outputStates[0] = true;
                this.timerValue = this.timerLimit;
            } else {
                if (this.timerValue > 0) {
                    this.timerValue--;
                    this.outputStates[0] = true;
                } else {
                    this.outputStates[0] = false;
                }
            }
        } 
        
        else if (this.type === 'CLOCK') {
            this.timerValue++;
            if (this.timerValue >= this.timerLimit) this.timerValue = 0;
            const threshold = (this.dutyCycle / 100) * this.timerLimit;
            this.outputStates[0] = (this.timerValue < threshold);
        }

        else if (this.type === 'SHIFT_REG') {
            const data = this.inputStates[0];
            const clk = this.inputStates[1];
            const rst = this.inputStates[2];
            if (rst) {
                this.outputStates.fill(false);
            } else if (clk && !this.prevClockState) {
                for (let i = 7; i > 0; i--) this.outputStates[i] = this.outputStates[i-1];
                this.outputStates[0] = data;
            }
            this.prevClockState = clk;
        }
        
        // SEVEN_SEG logic handled in Draw directly from inputs
    }

    getInputPos(index) {
        const spacing = this.h / (this.def.inputs + 1);
        return { x: this.x, y: this.y + spacing * (index + 1) };
    }

    getOutputPos(index) {
        const spacing = this.h / (this.def.outputs + 1);
        return { x: this.x + this.w, y: this.y + spacing * (index + 1) };
    }

    draw(ctx) {
        let fillColor = this.def.color;
        if (this.type.startsWith('LIGHT') && this.outputStates[0]) fillColor = this.def.onColor;
        if (this.type === 'PUSH_BTN' && this.outputStates[0]) fillColor = '#2ecc71';

        ctx.fillStyle = fillColor;
        
        if (this === draggingComponent) {
            ctx.shadowColor = 'rgba(255,255,255,0.5)';
            ctx.shadowBlur = 10;
        }

        // Body Shape
        ctx.beginPath();
        if (this.type === 'NOT') {
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + this.w, this.y + this.h/2);
            ctx.lineTo(this.x, this.y + this.h);
            ctx.closePath();
            ctx.fill();
        } else {
            roundRect(ctx, this.x, this.y, this.w, this.h, 6);
            ctx.fill();
        }
        ctx.shadowBlur = 0;

        // Label
        ctx.fillStyle = this.def.textColor || 'white';
        ctx.font = "bold 16px sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        
        if (this.type === 'TON' || this.type === 'TOF' || this.type === 'CLOCK') {
            let pct = this.timerValue / this.timerLimit;
            const barW = this.w - 20;
            const barX = this.x + 10;
            const barY = this.y + 40;
            
            ctx.fillText(this.def.label, this.x + this.w/2, this.y + 20);
            ctx.fillStyle = 'rgba(0,0,0,0.3)';
            ctx.fillRect(barX, barY, barW, 6);
            ctx.fillStyle = 'white';
            ctx.fillRect(barX, barY, barW * pct, 6);

            ctx.font = "10px sans-serif";
            const totalSec = (this.timeSetting * this.timeBase).toFixed(2) + "s";
            ctx.fillText(totalSec, this.x + this.w/2, this.y + 55);
        } else if (this.type === 'SHIFT_REG') {
            ctx.save();
            ctx.translate(this.x + this.w/2, this.y + this.h/2);
            ctx.rotate(-Math.PI/2);
            ctx.fillText("SHIFT REG", 0, 0);
            ctx.restore();
        } else if (this.type === 'SEVEN_SEG') {
            // Draw 7-Segment Display
            // Inputs: 0=a, 1=b, 2=c, 3=d, 4=e, 5=f, 6=g, 7=dp
            const segW = 6;
            const segL = 35;
            const cx = this.x + 45; // Center X of component body
            const cy = this.y + 75; // Center Y of component body
            
            // Helper to draw segment
            const drawSeg = (id, x, y, w, h) => {
                ctx.fillStyle = this.inputStates[id] ? '#ff0000' : '#4a0000'; // Neon Red vs Dark Red
                // Add glow if on
                if(this.inputStates[id]) {
                    ctx.shadowColor = '#ff0000';
                    ctx.shadowBlur = 10;
                } else {
                    ctx.shadowBlur = 0;
                }
                roundRect(ctx, x, y, w, h, 2);
                ctx.fill();
                ctx.shadowBlur = 0;
            };

            // Segment Positions relative to cx, cy
            // a: top
            drawSeg(0, cx - segL/2, cy - segL - segW, segL, segW);
            // b: top right
            drawSeg(1, cx + segL/2, cy - segL, segW, segL);
            // c: bottom right
            drawSeg(2, cx + segL/2, cy + segW, segW, segL);
            // d: bottom
            drawSeg(3, cx - segL/2, cy + segL + segW, segL, segW);
            // e: bottom left
            drawSeg(4, cx - segL/2 - segW, cy + segW, segW, segL);
            // f: top left
            drawSeg(5, cx - segL/2 - segW, cy - segL, segW, segL);
            // g: middle
            drawSeg(6, cx - segL/2, cy, segL, segW);
            // dp: decimal point (bottom right corner)
            ctx.fillStyle = this.inputStates[7] ? '#ff0000' : '#4a0000';
            if(this.inputStates[7]) { ctx.shadowColor = '#ff0000'; ctx.shadowBlur = 10; }
            ctx.beginPath();
            ctx.arc(cx + segL/2 + 10, cy + segL + segW + 2, 3, 0, Math.PI*2);
            ctx.fill();
            ctx.shadowBlur = 0;

        } else {
            let label = this.def.label;
            if (this.type === 'SWITCH') label = this.outputStates[0] ? 'ON' : 'OFF';
            ctx.fillText(label, this.x + this.w/2, this.y + this.h/2);
        }

        // Visual Indicator (LED)
        if (['SWITCH', 'PUSH_BTN', 'LATCH', 'RS_LATCH', 'CLOCK'].includes(this.type) || this.type.startsWith('LIGHT')) {
            ctx.beginPath();
            ctx.arc(this.x + this.w/2, this.y - 10, 6, 0, Math.PI*2);
            let ledColor = '#333';
            if (this.type.startsWith('LIGHT')) ledColor = this.outputStates[0] ? this.def.onColor : '#222';
            else ledColor = this.outputStates[0] ? WIRE_COLOR_ON : '#333';
            
            ctx.fillStyle = ledColor;
            ctx.fill();
            ctx.strokeStyle = '#fff';
            ctx.stroke();
        }

        // Input Pins
        ctx.fillStyle = '#fff';
        for(let i=0; i<this.def.inputs; i++) {
            const pos = this.getInputPos(i);
            ctx.fillRect(pos.x - 5, pos.y - 5, 10, 10);
            if (isHoveringPin(pos)) {
                ctx.strokeStyle = WIRE_COLOR_ON;
                ctx.strokeRect(pos.x - 7, pos.y - 7, 14, 14);
            }
            
            // Labels
            let label = "";
            ctx.fillStyle = 'rgba(255,255,255,0.7)';
            ctx.font = "bold 10px monospace";
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";

            if (this.type === 'LATCH') label = (i===0) ? "S" : "R";
            if (this.type === 'RS_LATCH') label = (i===0) ? "R" : "S";
            if (this.type === 'SHIFT_REG') {
                if(i===0) label = "D";
                if(i===1) label = ">";
                if(i===2) label = "R";
            }
            if (this.type === 'SEVEN_SEG') {
                const segLabels = ['a','b','c','d','e','f','g','dp'];
                label = segLabels[i];
            }

            if (label) ctx.fillText(label, pos.x + 10, pos.y);
            ctx.fillStyle = '#fff';
        }

        // Output Pins
        for(let i=0; i<this.def.outputs; i++) {
            const pos = this.getOutputPos(i);
            ctx.beginPath();
            ctx.arc(pos.x, pos.y, 5, 0, Math.PI*2);
            ctx.fill();
            if (isHoveringPin(pos)) {
                ctx.strokeStyle = WIRE_COLOR_ON;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, 8, 0, Math.PI*2);
                ctx.stroke();
            }
            
            if (this.type === 'SHIFT_REG') {
                ctx.fillStyle = 'rgba(255,255,255,0.7)';
                ctx.font = "bold 10px monospace";
                ctx.textAlign = "right";
                ctx.textBaseline = "middle";
                ctx.fillText("Q"+i, pos.x - 10, pos.y);
                ctx.fillStyle = '#fff';
            }
        }
    }
}

/**
 * UTILS
 */
function roundRect(ctx, x, y, w, h, r) {
    if (w < 2 * r) r = w / 2;
    if (h < 2 * r) r = h / 2;
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
}

function resizeCanvas() {
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

function getMousePos(e) {
    const rect = canvas.getBoundingClientRect();
    const clientX = e.touches ? e.touches[0].clientX : e.clientX;
    const clientY = e.touches ? e.touches[0].clientY : e.clientY;
    return {
        x: clientX - rect.left,
        y: clientY - rect.top
    };
}

function getWorldPos(screenPos) {
    return { x: screenPos.x - viewX, y: screenPos.y - viewY };
}

function isHoveringPin(worldPos) {
    const mouseWorld = getWorldPos(mousePos);
    return Math.hypot(mouseWorld.x - worldPos.x, mouseWorld.y - worldPos.y) < SNAP_DIST;
}

/**
 * MAIN LOOP
 */
function gameLoop() {
    // Reset Inputs
    components.forEach(c => {
        for(let i=0; i<c.def.inputs; i++) c.inputStates[i] = false;
    });

    // Propagate Logic
    wires.forEach(w => {
        // Source Component output state
        if (w.from.comp.outputStates[w.from.pinIdx]) {
            w.to.comp.inputStates[w.to.pinIdx] = true;
        }
    });

    // Update Logic
    components.forEach(c => c.update());

    draw();
    requestAnimationFrame(gameLoop);
}

function draw() {
    ctx.fillStyle = '#1a1a2e';
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Background Grid
    ctx.save();
    ctx.fillStyle = 'rgba(255,255,255,0.05)';
    const offsetX = viewX % GRID_SIZE;
    const offsetY = viewY % GRID_SIZE;
    for (let x = offsetX; x < canvas.width; x += GRID_SIZE) {
        for (let y = offsetY; y < canvas.height; y += GRID_SIZE) {
            ctx.fillRect(x, y, 1, 1);
        }
    }
    ctx.fillStyle = 'rgba(255, 0, 0, 0.5)';
    ctx.fillRect(viewX - 2, viewY - 2, 4, 4);
    ctx.restore();

    // World Content
    ctx.save();
    ctx.translate(viewX, viewY);

    // Wires
    wires.forEach(w => {
        const start = w.from.comp.getOutputPos(w.from.pinIdx);
        const end = w.to.comp.getInputPos(w.to.pinIdx);
        // Visual state check
        drawWire(start, end, w.from.comp.outputStates[w.from.pinIdx]);
    });

    // Temp Wire
    if (wiringStart) {
        let startPos, endPos, isActive;
        const mouseWorld = getWorldPos(mousePos);
        
        if (wiringStart.pinType === 'output') {
            startPos = wiringStart.comp.getOutputPos(wiringStart.pinIndex);
            endPos = mouseWorld;
            isActive = wiringStart.comp.outputStates[wiringStart.pinIndex];
        } else {
            startPos = mouseWorld;
            endPos = wiringStart.comp.getInputPos(wiringStart.pinIndex);
            isActive = false; 
        }
        drawWire(startPos, endPos, isActive);
    }

    components.forEach(c => c.draw(ctx));
    ctx.restore();
}

function drawWire(p1, p2, active) {
    ctx.beginPath();
    ctx.strokeStyle = active ? WIRE_COLOR_ON : WIRE_COLOR_OFF;
    ctx.lineWidth = 3;
    const cp1 = { x: p1.x + 50, y: p1.y };
    const cp2 = { x: p2.x - 50, y: p2.y };
    ctx.moveTo(p1.x, p1.y);
    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
    
    if (active) {
        ctx.shadowColor = WIRE_COLOR_ON;
        ctx.shadowBlur = 10;
    } else {
        ctx.shadowBlur = 0;
    }
    ctx.stroke();
    ctx.shadowBlur = 0;
}

/**
 * INTERACTION
 */
const toolItems = document.querySelectorAll('.tool-item');
toolItems.forEach(item => {
    item.addEventListener('dragstart', (e) => {
        e.dataTransfer.setData('type', item.dataset.type);
    });
});

container.addEventListener('dragover', (e) => e.preventDefault());
container.addEventListener('drop', (e) => {
    e.preventDefault();
    const type = e.dataTransfer.getData('type');
    const rect = canvas.getBoundingClientRect();
    const worldX = e.clientX - rect.left - 30 - viewX;
    const worldY = e.clientY - rect.top - 30 - viewY;
    const snapX = Math.round(worldX / GRID_SIZE) * GRID_SIZE;
    const snapY = Math.round(worldY / GRID_SIZE) * GRID_SIZE;
    components.push(new Component(type, snapX, snapY));
});

canvas.addEventListener('mousedown', handleInputStart);
window.addEventListener('mousemove', handleInputMove);
window.addEventListener('mouseup', handleInputEnd);

canvas.addEventListener('contextmenu', (e) => {
    e.preventDefault();
    mousePos = getMousePos(e);
    const mouseWorld = getWorldPos(mousePos);
    
    let pinClicked = false;
    components.forEach(c => {
        // Inputs
        for(let i=0; i<c.def.inputs; i++) {
            const pos = c.getInputPos(i);
            if(Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y) < SNAP_DIST) {
                wires = wires.filter(w => !(w.to.comp === c && w.to.pinIdx === i));
                pinClicked = true;
            }
        }
        // Outputs
        for(let i=0; i<c.def.outputs; i++) {
             const pos = c.getOutputPos(i);
             if(Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y) < SNAP_DIST) {
                 wires = wires.filter(w => !(w.from.comp === c && w.from.pinIdx === i));
                 pinClicked = true;
             }
        }
    });
    if (pinClicked) return;

    const clickedComp = components.find(c => 
        mouseWorld.x >= c.x && mouseWorld.x <= c.x + c.w &&
        mouseWorld.y >= c.y && mouseWorld.y <= c.y + c.h
    );

    if (clickedComp) {
        const now = Date.now();
        if (lastRightClickId === clickedComp.id && (now - lastRightClickTime < 300)) {
            wires = wires.filter(w => w.from.comp !== clickedComp && w.to.comp !== clickedComp);
            components = components.filter(c => c !== clickedComp);
            closeConfig();
            lastRightClickId = null;
            return;
        }
        lastRightClickId = clickedComp.id;
        lastRightClickTime = now;

        if (clickedComp.type === 'TON' || clickedComp.type === 'TOF' || clickedComp.type === 'CLOCK') {
            openConfig(clickedComp);
        }
    }
});

function handleInputStart(e) {
    if(e.button !== 0) return; 
    mousePos = getMousePos(e);
    const mouseWorld = getWorldPos(mousePos);
    
    // Check Pins
    for (let c of components) {
        for(let i=0; i<c.def.outputs; i++) {
            const pos = c.getOutputPos(i);
            if (Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y) < SNAP_DIST) {
                wiringStart = { comp: c, pinType: 'output', pinIndex: i };
                return;
            }
        }
        for(let i=0; i<c.def.inputs; i++) {
            const pos = c.getInputPos(i);
            if (Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y) < SNAP_DIST) {
                wiringStart = { comp: c, pinType: 'input', pinIndex: i };
                return;
            }
        }
    }

    // Check Components
    for (let i = components.length - 1; i >= 0; i--) {
        let c = components[i];
        if (mouseWorld.x >= c.x && mouseWorld.x <= c.x + c.w &&
            mouseWorld.y >= c.y && mouseWorld.y <= c.y + c.h) {
            
            // Push Button Logic
            if (c.type === 'PUSH_BTN') {
                c.outputStates[0] = true;
                pressedButtonId = c.id;
            }
            
            draggingComponent = c;
            dragOffset = { x: mouseWorld.x - c.x, y: mouseWorld.y - c.y };
            dragStartPos = { x: mouseWorld.x, y: mouseWorld.y };
            isDraggingComp = false; 
            components.splice(i, 1);
            components.push(c);
            return;
        }
    }

    isPanning = true;
    panStart = { x: mousePos.x - viewX, y: mousePos.y - viewY };
    container.style.cursor = "grabbing";
}

function handleInputMove(e) {
    mousePos = getMousePos(e);
    const mouseWorld = getWorldPos(mousePos);
    
    if (draggingComponent) {
        const dist = Math.hypot(mouseWorld.x - dragStartPos.x, mouseWorld.y - dragStartPos.y);
        if (dist > 5) {
            isDraggingComp = true;
            draggingComponent.x = Math.round((mouseWorld.x - dragOffset.x) / GRID_SIZE) * GRID_SIZE;
            draggingComponent.y = Math.round((mouseWorld.y - dragOffset.y) / GRID_SIZE) * GRID_SIZE;
        }
    } else if (isPanning) {
        viewX = mousePos.x - panStart.x;
        viewY = mousePos.y - panStart.y;
    }
}

function handleInputEnd(e) {
    // Release Push Button
    if (pressedButtonId) {
        const btn = components.find(c => c.id === pressedButtonId);
        if (btn) btn.outputStates[0] = false;
        pressedButtonId = null;
    }

    if (draggingComponent && draggingComponent.type === 'SWITCH' && !isDraggingComp) {
        draggingComponent.outputStates[0] = !draggingComponent.outputStates[0];
    }

    if (wiringStart) {
        const mouseWorld = getWorldPos(mousePos);
        for (let c of components) {
            if (wiringStart.pinType === 'output') {
                for(let i=0; i<c.def.inputs; i++) {
                    const pos = c.getInputPos(i);
                    if (Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y) < SNAP_DIST) {
                        if (c === wiringStart.comp) continue;
                        wires = wires.filter(w => !(w.to.comp === c && w.to.pinIdx === i));
                        wires.push({ from: { comp: wiringStart.comp, pinIdx: wiringStart.pinIndex }, to: { comp: c, pinIdx: i } });
                    }
                }
            } else {
                 for(let i=0; i<c.def.outputs; i++) {
                    const pos = c.getOutputPos(i);
                    if (Math.hypot(mouseWorld.x - pos.x, mouseWorld.y - pos.y) < SNAP_DIST) {
                        if (c === wiringStart.comp) continue;
                        wires = wires.filter(w => !(w.to.comp === wiringStart.comp && w.to.pinIdx === wiringStart.pinIndex));
                        wires.push({ from: { comp: c, pinIdx: i }, to: { comp: wiringStart.comp, pinIdx: wiringStart.pinIndex } });
                    }
                }
            }
        }
        wiringStart = null;
    }
    
    draggingComponent = null;
    isDraggingComp = false;
    isPanning = false;
    container.style.cursor = "crosshair";
}

// CONFIG UI LOGIC
function openConfig(comp) {
    editingComponent = comp;
    const panel = document.getElementById('configPanel');
    const slider = document.getElementById('timerSlider');
    const valDisplay = document.getElementById('valDisplay');
    const dutyRow = document.getElementById('dutyRow');
    const dutySlider = document.getElementById('dutySlider');
    const dutyDisplay = document.getElementById('dutyDisplay');
    
    slider.value = comp.timeSetting;
    valDisplay.textContent = comp.timeSetting;
    
    const radios = document.getElementsByName('timebase');
    for(let r of radios) {
        if(parseFloat(r.value) === comp.timeBase) r.checked = true;
    }

    if (comp.type === 'CLOCK') {
        dutyRow.style.display = 'block';
        dutySlider.value = comp.dutyCycle;
        dutyDisplay.textContent = comp.dutyCycle;
    } else {
        dutyRow.style.display = 'none';
    }

    panel.style.display = 'block';
}

function updateValDisplay(val) {
    document.getElementById('valDisplay').textContent = val;
}
function updateDutyDisplay(val) {
    document.getElementById('dutyDisplay').textContent = val;
}

function saveConfig() {
    if (!editingComponent) return;
    const sliderVal = document.getElementById('timerSlider').value;
    const dutyVal = document.getElementById('dutySlider').value;
    const radios = document.getElementsByName('timebase');
    let baseVal = 1;
    for(let r of radios) {
        if (r.checked) baseVal = r.value;
    }
    
    editingComponent.updateConfig(sliderVal, baseVal, dutyVal);
    closeConfig();
}

function closeConfig() {
    document.getElementById('configPanel').style.display = 'none';
    editingComponent = null;
}

function clearBoard() {
    if(confirm("Clear all components?")) {
        components = [];
        wires = [];
        viewX = 0;
        viewY = 0;
    }
}

function toggleHelp() {
    const modal = document.getElementById('helpModal');
    modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex';
}

requestAnimationFrame(gameLoop);

function loadDemo() {
    const clk = new Component('CLOCK', 100, 100);
    const sreg = new Component('SHIFT_REG', 300, 100);
    const sw = new Component('SWITCH', 100, 200);
    
    components.push(clk, sreg, sw);
    
    wires.push({ from: {comp: clk, pinIdx: 0}, to: {comp: sreg, pinIdx: 1} }); // Clock to Clock
    wires.push({ from: {comp: sw, pinIdx: 0}, to: {comp: sreg, pinIdx: 0} });  // Switch to Data
}
setTimeout(loadDemo, 100);

</script>
</body>
</html>


